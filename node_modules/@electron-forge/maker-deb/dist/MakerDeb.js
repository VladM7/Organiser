"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debianArch = debianArch;
exports.default = void 0;

require("source-map-support/register");

var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function debianArch(nodeArch) {
  switch (nodeArch) {
    case 'ia32':
      return 'i386';

    case 'x64':
      return 'amd64';

    case 'armv7l':
      return 'armhf';

    case 'arm':
      return 'armel';

    default:
      return nodeArch;
  }
}

class MakerDeb extends _makerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'deb');

    _defineProperty(this, "defaultPlatforms", ['linux']);

    _defineProperty(this, "requiredExternalBinaries", ['dpkg', 'fakeroot']);
  }

  isSupportedOnCurrentPlatform() {
    return this.isInstalled('electron-installer-debian');
  }

  async make({
    dir,
    makeDir,
    targetArch
  }) {
    // eslint-disable-next-line global-require, import/no-unresolved, node/no-missing-require
    const installer = require('electron-installer-debian');

    const outDir = _path.default.resolve(makeDir, 'deb', targetArch);

    await this.ensureDirectory(outDir);
    const {
      packagePaths
    } = await installer({
      options: {},
      ...this.config,
      arch: debianArch(targetArch),
      src: dir,
      dest: outDir,
      rename: undefined
    });
    return packagePaths;
  }

}

exports.default = MakerDeb;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlckRlYi50cyJdLCJuYW1lcyI6WyJkZWJpYW5BcmNoIiwibm9kZUFyY2giLCJNYWtlckRlYiIsIk1ha2VyQmFzZSIsImlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0iLCJpc0luc3RhbGxlZCIsIm1ha2UiLCJkaXIiLCJtYWtlRGlyIiwidGFyZ2V0QXJjaCIsImluc3RhbGxlciIsInJlcXVpcmUiLCJvdXREaXIiLCJwYXRoIiwicmVzb2x2ZSIsImVuc3VyZURpcmVjdG9yeSIsInBhY2thZ2VQYXRocyIsIm9wdGlvbnMiLCJjb25maWciLCJhcmNoIiwic3JjIiwiZGVzdCIsInJlbmFtZSIsInVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUVBOzs7Ozs7QUFJTyxTQUFTQSxVQUFULENBQW9CQyxRQUFwQixFQUFpRDtBQUN0RCxVQUFRQSxRQUFSO0FBQ0UsU0FBSyxNQUFMO0FBQ0UsYUFBTyxNQUFQOztBQUNGLFNBQUssS0FBTDtBQUNFLGFBQU8sT0FBUDs7QUFDRixTQUFLLFFBQUw7QUFDRSxhQUFPLE9BQVA7O0FBQ0YsU0FBSyxLQUFMO0FBQ0UsYUFBTyxPQUFQOztBQUNGO0FBQ0UsYUFBT0EsUUFBUDtBQVZKO0FBWUQ7O0FBRWMsTUFBTUMsUUFBTixTQUF1QkMsa0JBQXZCLENBQWlEO0FBQUE7QUFBQTs7QUFBQSxrQ0FDdkQsS0FEdUQ7O0FBQUEsOENBRzFCLENBQUMsT0FBRCxDQUgwQjs7QUFBQSxzREFLekIsQ0FBQyxNQUFELEVBQVMsVUFBVCxDQUx5QjtBQUFBOztBQU85REMsRUFBQUEsNEJBQTRCLEdBQVk7QUFDdEMsV0FBTyxLQUFLQyxXQUFMLENBQWlCLDJCQUFqQixDQUFQO0FBQ0Q7O0FBRVMsUUFBSkMsSUFBSSxDQUFDO0FBQUVDLElBQUFBLEdBQUY7QUFBT0MsSUFBQUEsT0FBUDtBQUFnQkMsSUFBQUE7QUFBaEIsR0FBRCxFQUFnRTtBQUN4RTtBQUNBLFVBQU1DLFNBQVMsR0FBR0MsT0FBTyxDQUFDLDJCQUFELENBQXpCOztBQUVBLFVBQU1DLE1BQU0sR0FBR0MsY0FBS0MsT0FBTCxDQUFhTixPQUFiLEVBQXNCLEtBQXRCLEVBQTZCQyxVQUE3QixDQUFmOztBQUVBLFVBQU0sS0FBS00sZUFBTCxDQUFxQkgsTUFBckIsQ0FBTjtBQUNBLFVBQU07QUFBRUksTUFBQUE7QUFBRixRQUFtQixNQUFNTixTQUFTLENBQUM7QUFDdkNPLE1BQUFBLE9BQU8sRUFBRSxFQUQ4QjtBQUV2QyxTQUFHLEtBQUtDLE1BRitCO0FBR3ZDQyxNQUFBQSxJQUFJLEVBQUVuQixVQUFVLENBQUNTLFVBQUQsQ0FIdUI7QUFJdkNXLE1BQUFBLEdBQUcsRUFBRWIsR0FKa0M7QUFLdkNjLE1BQUFBLElBQUksRUFBRVQsTUFMaUM7QUFNdkNVLE1BQUFBLE1BQU0sRUFBRUM7QUFOK0IsS0FBRCxDQUF4QztBQVNBLFdBQU9QLFlBQVA7QUFDRDs7QUE1QjZEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1ha2VyQmFzZSwgeyBNYWtlck9wdGlvbnMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvbWFrZXItYmFzZSc7XG5pbXBvcnQgeyBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0gfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2Uvc2hhcmVkLXR5cGVzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBNYWtlckRlYkNvbmZpZyB9IGZyb20gJy4vQ29uZmlnJztcblxuZXhwb3J0IGZ1bmN0aW9uIGRlYmlhbkFyY2gobm9kZUFyY2g6IEZvcmdlQXJjaCk6IHN0cmluZyB7XG4gIHN3aXRjaCAobm9kZUFyY2gpIHtcbiAgICBjYXNlICdpYTMyJzpcbiAgICAgIHJldHVybiAnaTM4Nic7XG4gICAgY2FzZSAneDY0JzpcbiAgICAgIHJldHVybiAnYW1kNjQnO1xuICAgIGNhc2UgJ2FybXY3bCc6XG4gICAgICByZXR1cm4gJ2FybWhmJztcbiAgICBjYXNlICdhcm0nOlxuICAgICAgcmV0dXJuICdhcm1lbCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBub2RlQXJjaDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWtlckRlYiBleHRlbmRzIE1ha2VyQmFzZTxNYWtlckRlYkNvbmZpZz4ge1xuICBuYW1lID0gJ2RlYic7XG5cbiAgZGVmYXVsdFBsYXRmb3JtczogRm9yZ2VQbGF0Zm9ybVtdID0gWydsaW51eCddO1xuXG4gIHJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllczogc3RyaW5nW10gPSBbJ2Rwa2cnLCAnZmFrZXJvb3QnXTtcblxuICBpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzSW5zdGFsbGVkKCdlbGVjdHJvbi1pbnN0YWxsZXItZGViaWFuJyk7XG4gIH1cblxuICBhc3luYyBtYWtlKHsgZGlyLCBtYWtlRGlyLCB0YXJnZXRBcmNoIH06IE1ha2VyT3B0aW9ucyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsIGltcG9ydC9uby11bnJlc29sdmVkLCBub2RlL25vLW1pc3NpbmctcmVxdWlyZVxuICAgIGNvbnN0IGluc3RhbGxlciA9IHJlcXVpcmUoJ2VsZWN0cm9uLWluc3RhbGxlci1kZWJpYW4nKTtcblxuICAgIGNvbnN0IG91dERpciA9IHBhdGgucmVzb2x2ZShtYWtlRGlyLCAnZGViJywgdGFyZ2V0QXJjaCk7XG5cbiAgICBhd2FpdCB0aGlzLmVuc3VyZURpcmVjdG9yeShvdXREaXIpO1xuICAgIGNvbnN0IHsgcGFja2FnZVBhdGhzIH0gPSBhd2FpdCBpbnN0YWxsZXIoe1xuICAgICAgb3B0aW9uczoge30sXG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIGFyY2g6IGRlYmlhbkFyY2godGFyZ2V0QXJjaCksXG4gICAgICBzcmM6IGRpcixcbiAgICAgIGRlc3Q6IG91dERpcixcbiAgICAgIHJlbmFtZTogdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhY2thZ2VQYXRocztcbiAgfVxufVxuIl19