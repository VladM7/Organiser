"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _which = _interopRequireDefault(require("which"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Maker {
  constructor(configFetcher = {}, providedPlatforms) {
    this.configFetcher = configFetcher;
    this.providedPlatforms = providedPlatforms;

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "defaultPlatforms", void 0);

    _defineProperty(this, "requiredExternalBinaries", []);

    _defineProperty(this, "__isElectronForgeMaker", void 0);

    Object.defineProperty(this, '__isElectronForgeMaker', {
      value: true,
      enumerable: false,
      configurable: false
    });
  }

  get platforms() {
    if (this.providedPlatforms) return this.providedPlatforms;
    return this.defaultPlatforms;
  } // TODO: Remove this, it is an eye-sore and is a nasty hack to provide forge
  //       v5 style functionality in the new API


  prepareConfig(targetArch) {
    if (typeof this.configFetcher === 'function') {
      this.config = this.configFetcher(targetArch);
    } else {
      this.config = this.configFetcher;
    }
  }
  /**
   * Makers must implement this method and return true or false indicating whether
   * this maker can be run on the current platform.  Normally this is just a process.platform
   * check but it can be a deeper check for dependencies like fake-root or other
   * required external build tools.
   *
   * If the issue is a missing dependency you should log out a HELPFUL error message
   * telling the developer exactly what is missing and if possible how to get it.
   */


  isSupportedOnCurrentPlatform() {
    if (this.isSupportedOnCurrentPlatform === Maker.prototype.isSupportedOnCurrentPlatform) {
      throw new Error(`Maker ${this.name} did not implement the isSupportedOnCurrentPlatform method`);
    }

    return true;
  }
  /**
   * Makers must implement this method and return an array of absolute paths
   * to the artifacts generated by your maker
   */


  async make(opts) {
    // eslint-disable-line max-len, @typescript-eslint/no-unused-vars
    if (this.make === Maker.prototype.make) {
      throw new Error(`Maker ${this.name} did not implement the make method`);
    }

    return [];
  }
  /**
   * Helpers
   */

  /**
   * Ensures the directory exists and is forced to be empty.
   *
   * I.e. If the directory already exists it is deleted and recreated, this
   * is a destructive operation
   */


  async ensureDirectory(dir) {
    if (await _fsExtra.default.pathExists(dir)) {
      await _fsExtra.default.remove(dir);
    }

    return _fsExtra.default.mkdirs(dir);
  }
  /**
   * Ensures the path to the file exists and the file does not exist
   *
   * I.e. If the file already exists it is deleted and the path created
   */


  async ensureFile(file) {
    if (await _fsExtra.default.pathExists(file)) {
      await _fsExtra.default.remove(file);
    }

    await _fsExtra.default.mkdirs(_path.default.dirname(file));
  }
  /**
   * Checks if the specified binaries exist, which are required for the maker to be used.
   */


  externalBinariesExist() {
    return this.requiredExternalBinaries.every(binary => _which.default.sync(binary, {
      nothrow: true
    }) !== null);
  }
  /**
   * Throws an error if any of the binaries don't exist.
   */


  ensureExternalBinariesExist() {
    if (!this.externalBinariesExist()) {
      throw new Error(`Cannot make for ${this.name}, the following external binaries need to be installed: ${this.requiredExternalBinaries.join(', ')}`);
    }
  }
  /**
   * Checks if the given module is installed, used for testing if optional dependencies
   * are installed or not
   */


  isInstalled(module) {
    try {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      require(module);

      return true;
    } catch (e) {
      // Package doesn't exist -- must not be installable on this platform
      return false;
    }
  }
  /**
   * Normalize the given semver-formatted version to a 4-part dot delimited version number without
   * prerelease information for use in Windows apps.
   */


  normalizeWindowsVersion(version) {
    const noPrerelease = version.replace(/-.*/, '');
    return `${noPrerelease}.0`;
  }

}

exports.default = Maker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlci50cyJdLCJuYW1lcyI6WyJNYWtlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnRmV0Y2hlciIsInByb3ZpZGVkUGxhdGZvcm1zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJwbGF0Zm9ybXMiLCJkZWZhdWx0UGxhdGZvcm1zIiwicHJlcGFyZUNvbmZpZyIsInRhcmdldEFyY2giLCJjb25maWciLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwicHJvdG90eXBlIiwiRXJyb3IiLCJuYW1lIiwibWFrZSIsIm9wdHMiLCJlbnN1cmVEaXJlY3RvcnkiLCJkaXIiLCJmcyIsInBhdGhFeGlzdHMiLCJyZW1vdmUiLCJta2RpcnMiLCJlbnN1cmVGaWxlIiwiZmlsZSIsInBhdGgiLCJkaXJuYW1lIiwiZXh0ZXJuYWxCaW5hcmllc0V4aXN0IiwicmVxdWlyZWRFeHRlcm5hbEJpbmFyaWVzIiwiZXZlcnkiLCJiaW5hcnkiLCJ3aGljaCIsInN5bmMiLCJub3Rocm93IiwiZW5zdXJlRXh0ZXJuYWxCaW5hcmllc0V4aXN0Iiwiam9pbiIsImlzSW5zdGFsbGVkIiwibW9kdWxlIiwicmVxdWlyZSIsImUiLCJub3JtYWxpemVXaW5kb3dzVmVyc2lvbiIsInZlcnNpb24iLCJub1ByZXJlbGVhc2UiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFHQTs7QUFDQTs7QUFDQTs7Ozs7O0FBa0NlLE1BQWVBLEtBQWYsQ0FBK0M7QUFXNURDLEVBQUFBLFdBQVcsQ0FDREMsYUFBNkMsR0FBRyxFQUQvQyxFQUVDQyxpQkFGRCxFQUdUO0FBQUEsU0FGUUQsYUFFUixHQUZRQSxhQUVSO0FBQUEsU0FEVUMsaUJBQ1YsR0FEVUEsaUJBQ1Y7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUEsc0RBUDBDLEVBTzFDOztBQUFBOztBQUNBQyxJQUFBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0IsSUFB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SUUsT0FBT0UsQ0FBUCxFQUFVO0FBQ1Y7QUFDQSxhQUFPLEtBQVA7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7OztBQUNFQyxFQUFBQSx1QkFBdUIsQ0FBQ0MsT0FBRCxFQUEwQjtBQUMvQyxVQUFNQyxZQUFZLEdBQUdELE9BQU8sQ0FBQ0UsT0FBUixDQUFnQixLQUFoQixFQUF1QixFQUF2QixDQUFyQjtBQUNBLFdBQVEsR0FBRUQsWUFBYSxJQUF2QjtBQUNEOztBQXJJMkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBGb3JnZUFyY2gsIEZvcmdlQ29uZmlnLCBGb3JnZVBsYXRmb3JtLCBJRm9yZ2VNYWtlcixcbn0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgd2hpY2ggZnJvbSAnd2hpY2gnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1ha2VyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIHBhY2thZ2VkIEVsZWN0cm9uIGFwcGxpY2F0aW9uXG4gICAqL1xuICBkaXI6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RvcnkgeW91IHNob3VsZCBwdXQgYWxsIHlvdXIgYXJ0aWZhY3RzIGluIChwb3RlbnRpYWxseSBpbiBzdWIgZm9sZGVycylcbiAgICogTk9URTogdGhpcyBkaXJlY3RvcnkgaXMgbm90IGd1YXJ1bnRlZWQgdG8gYWxyZWFkeSBleGlzdFxuICAgKi9cbiAgbWFrZURpcjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJlc29sdmVkIGh1bWFuIGZyaWVuZGx5IG5hbWUgb2YgdGhlIHByb2plY3RcbiAgICovXG4gIGFwcE5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgcGxhdGZvcm0geW91IHNob3VsZCBtYWtlIGZvclxuICAgKi9cbiAgdGFyZ2V0UGxhdGZvcm06IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IGFyY2hpdGVjdHVyZSB5b3Ugc2hvdWxkIG1ha2UgZm9yXG4gICAqL1xuICB0YXJnZXRBcmNoOiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBGdWxseSByZXNvbHZlZCBmb3JnZSBjb25maWd1cmF0aW9uLCB5b3Ugc2hvdWxkbid0IHJlYWxseSBuZWVkIHRoaXNcbiAgICovXG4gIGZvcmdlQ29uZmlnOiBGb3JnZUNvbmZpZztcbiAgLyoqXG4gICAqIFRoZSBhcHBsaWNhdGlvbnMgcGFja2FnZS5qc29uIGZpbGVcbiAgICovXG4gIHBhY2thZ2VKU09OOiBhbnk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIE1ha2VyPEM+IGltcGxlbWVudHMgSUZvcmdlTWFrZXIge1xuICBwdWJsaWMgY29uZmlnITogQztcblxuICBwdWJsaWMgYWJzdHJhY3QgbmFtZTogc3RyaW5nO1xuXG4gIHB1YmxpYyBhYnN0cmFjdCBkZWZhdWx0UGxhdGZvcm1zOiBGb3JnZVBsYXRmb3JtW107XG5cbiAgcHVibGljIHJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllczogc3RyaW5nW10gPSBbXTtcblxuICBfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyITogdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbmZpZ0ZldGNoZXI6IChDIHwgKChhcmNoOiBGb3JnZUFyY2gpID0+IEMpKSA9IHt9IGFzIEMsXG4gICAgcHJvdGVjdGVkIHByb3ZpZGVkUGxhdGZvcm1zPzogRm9yZ2VQbGF0Zm9ybVtdLFxuICApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19faXNFbGVjdHJvbkZvcmdlTWFrZXInLCB7XG4gICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBwbGF0Zm9ybXMoKSB7XG4gICAgaWYgKHRoaXMucHJvdmlkZWRQbGF0Zm9ybXMpIHJldHVybiB0aGlzLnByb3ZpZGVkUGxhdGZvcm1zO1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRQbGF0Zm9ybXM7XG4gIH1cblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcywgaXQgaXMgYW4gZXllLXNvcmUgYW5kIGlzIGEgbmFzdHkgaGFjayB0byBwcm92aWRlIGZvcmdlXG4gIC8vICAgICAgIHY1IHN0eWxlIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIG5ldyBBUElcbiAgcHJlcGFyZUNvbmZpZyh0YXJnZXRBcmNoOiBGb3JnZUFyY2gpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuY29uZmlnRmV0Y2hlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jb25maWcgPSAodGhpcy5jb25maWdGZXRjaGVyIGFzIGFueSBhcyAoKGFyY2g6IEZvcmdlQXJjaCkgPT4gQykpKHRhcmdldEFyY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuY29uZmlnRmV0Y2hlciBhcyBDO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcnMgbXVzdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgYW5kIHJldHVybiB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlclxuICAgKiB0aGlzIG1ha2VyIGNhbiBiZSBydW4gb24gdGhlIGN1cnJlbnQgcGxhdGZvcm0uICBOb3JtYWxseSB0aGlzIGlzIGp1c3QgYSBwcm9jZXNzLnBsYXRmb3JtXG4gICAqIGNoZWNrIGJ1dCBpdCBjYW4gYmUgYSBkZWVwZXIgY2hlY2sgZm9yIGRlcGVuZGVuY2llcyBsaWtlIGZha2Utcm9vdCBvciBvdGhlclxuICAgKiByZXF1aXJlZCBleHRlcm5hbCBidWlsZCB0b29scy5cbiAgICpcbiAgICogSWYgdGhlIGlzc3VlIGlzIGEgbWlzc2luZyBkZXBlbmRlbmN5IHlvdSBzaG91bGQgbG9nIG91dCBhIEhFTFBGVUwgZXJyb3IgbWVzc2FnZVxuICAgKiB0ZWxsaW5nIHRoZSBkZXZlbG9wZXIgZXhhY3RseSB3aGF0IGlzIG1pc3NpbmcgYW5kIGlmIHBvc3NpYmxlIGhvdyB0byBnZXQgaXQuXG4gICAqL1xuICBpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0gPT09IE1ha2VyLnByb3RvdHlwZS5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ha2VyICR7dGhpcy5uYW1lfSBkaWQgbm90IGltcGxlbWVudCB0aGUgaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSBtZXRob2RgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogTWFrZXJzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgYWJzb2x1dGUgcGF0aHNcbiAgICogdG8gdGhlIGFydGlmYWN0cyBnZW5lcmF0ZWQgYnkgeW91ciBtYWtlclxuICAgKi9cbiAgYXN5bmMgbWFrZShvcHRzOiBNYWtlck9wdGlvbnMpOiBQcm9taXNlPHN0cmluZ1tdPiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgaWYgKHRoaXMubWFrZSA9PT0gTWFrZXIucHJvdG90eXBlLm1ha2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFrZXIgJHt0aGlzLm5hbWV9IGRpZCBub3QgaW1wbGVtZW50IHRoZSBtYWtlIG1ldGhvZGApO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyc1xuICAgKi9cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGUgZGlyZWN0b3J5IGV4aXN0cyBhbmQgaXMgZm9yY2VkIHRvIGJlIGVtcHR5LlxuICAgKlxuICAgKiBJLmUuIElmIHRoZSBkaXJlY3RvcnkgYWxyZWFkeSBleGlzdHMgaXQgaXMgZGVsZXRlZCBhbmQgcmVjcmVhdGVkLCB0aGlzXG4gICAqIGlzIGEgZGVzdHJ1Y3RpdmUgb3BlcmF0aW9uXG4gICAqL1xuICBhc3luYyBlbnN1cmVEaXJlY3RvcnkoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhkaXIpKSB7XG4gICAgICBhd2FpdCBmcy5yZW1vdmUoZGlyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZzLm1rZGlycyhkaXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIHBhdGggdG8gdGhlIGZpbGUgZXhpc3RzIGFuZCB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdFxuICAgKlxuICAgKiBJLmUuIElmIHRoZSBmaWxlIGFscmVhZHkgZXhpc3RzIGl0IGlzIGRlbGV0ZWQgYW5kIHRoZSBwYXRoIGNyZWF0ZWRcbiAgICovXG4gIGFzeW5jIGVuc3VyZUZpbGUoZmlsZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoZmlsZSkpIHtcbiAgICAgIGF3YWl0IGZzLnJlbW92ZShmaWxlKTtcbiAgICB9XG4gICAgYXdhaXQgZnMubWtkaXJzKHBhdGguZGlybmFtZShmaWxlKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgYmluYXJpZXMgZXhpc3QsIHdoaWNoIGFyZSByZXF1aXJlZCBmb3IgdGhlIG1ha2VyIHRvIGJlIHVzZWQuXG4gICAqL1xuICBleHRlcm5hbEJpbmFyaWVzRXhpc3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZWRFeHRlcm5hbEJpbmFyaWVzLmV2ZXJ5KFxuICAgICAgKGJpbmFyeSkgPT4gd2hpY2guc3luYyhiaW5hcnksIHsgbm90aHJvdzogdHJ1ZSB9KSAhPT0gbnVsbCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIGJpbmFyaWVzIGRvbid0IGV4aXN0LlxuICAgKi9cbiAgZW5zdXJlRXh0ZXJuYWxCaW5hcmllc0V4aXN0KCkge1xuICAgIGlmICghdGhpcy5leHRlcm5hbEJpbmFyaWVzRXhpc3QoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbWFrZSBmb3IgJHt0aGlzLm5hbWV9LCB0aGUgZm9sbG93aW5nIGV4dGVybmFsIGJpbmFyaWVzIG5lZWQgdG8gYmUgaW5zdGFsbGVkOiAke3RoaXMucmVxdWlyZWRFeHRlcm5hbEJpbmFyaWVzLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gbW9kdWxlIGlzIGluc3RhbGxlZCwgdXNlZCBmb3IgdGVzdGluZyBpZiBvcHRpb25hbCBkZXBlbmRlbmNpZXNcbiAgICogYXJlIGluc3RhbGxlZCBvciBub3RcbiAgICovXG4gIGlzSW5zdGFsbGVkKG1vZHVsZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZSwgaW1wb3J0L25vLWR5bmFtaWMtcmVxdWlyZVxuICAgICAgcmVxdWlyZShtb2R1bGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUGFja2FnZSBkb2Vzbid0IGV4aXN0IC0tIG11c3Qgbm90IGJlIGluc3RhbGxhYmxlIG9uIHRoaXMgcGxhdGZvcm1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHRoZSBnaXZlbiBzZW12ZXItZm9ybWF0dGVkIHZlcnNpb24gdG8gYSA0LXBhcnQgZG90IGRlbGltaXRlZCB2ZXJzaW9uIG51bWJlciB3aXRob3V0XG4gICAqIHByZXJlbGVhc2UgaW5mb3JtYXRpb24gZm9yIHVzZSBpbiBXaW5kb3dzIGFwcHMuXG4gICAqL1xuICBub3JtYWxpemVXaW5kb3dzVmVyc2lvbih2ZXJzaW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5vUHJlcmVsZWFzZSA9IHZlcnNpb24ucmVwbGFjZSgvLS4qLywgJycpO1xuICAgIHJldHVybiBgJHtub1ByZXJlbGVhc2V9LjBgO1xuICB9XG59XG4iXX0=