"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _which = _interopRequireDefault(require("which"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Maker {
  constructor(configFetcher = {}, providedPlatforms) {
    this.configFetcher = configFetcher;
    this.providedPlatforms = providedPlatforms;

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "defaultPlatforms", void 0);

    _defineProperty(this, "requiredExternalBinaries", []);

    _defineProperty(this, "__isElectronForgeMaker", void 0);

    Object.defineProperty(this, '__isElectronForgeMaker', {
      value: true,
      enumerable: false,
      configurable: false
    });
  }

  get platforms() {
    if (this.providedPlatforms) return this.providedPlatforms;
    return this.defaultPlatforms;
  } // TODO: Remove this, it is an eye-sore and is a nasty hack to provide forge
  //       v5 style functionality in the new API


  prepareConfig(targetArch) {
    if (typeof this.configFetcher === 'function') {
      this.config = this.configFetcher(targetArch);
    } else {
      this.config = this.configFetcher;
    }
  }
  /**
   * Makers must implement this method and return true or false indicating whether
   * this maker can be run on the current platform.  Normally this is just a process.platform
   * check but it can be a deeper check for dependencies like fake-root or other
   * required external build tools.
   *
   * If the issue is a missing dependency you should log out a HELPFUL error message
   * telling the developer exactly what is missing and if possible how to get it.
   */


  isSupportedOnCurrentPlatform() {
    if (this.isSupportedOnCurrentPlatform === Maker.prototype.isSupportedOnCurrentPlatform) {
      throw new Error(`Maker ${this.name} did not implement the isSupportedOnCurrentPlatform method`);
    }

    return true;
  }
  /**
   * Makers must implement this method and return an array of absolute paths
   * to the artifacts generated by your maker
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  async make(opts) {
    if (this.make === Maker.prototype.make) {
      throw new Error(`Maker ${this.name} did not implement the make method`);
    }

    return [];
  }
  /**
   * Helpers
   */

  /**
   * Ensures the directory exists and is forced to be empty.
   *
   * I.e. If the directory already exists it is deleted and recreated, this
   * is a destructive operation
   */


  async ensureDirectory(dir) {
    if (await _fsExtra.default.pathExists(dir)) {
      await _fsExtra.default.remove(dir);
    }

    return _fsExtra.default.mkdirs(dir);
  }
  /**
   * Ensures the path to the file exists and the file does not exist
   *
   * I.e. If the file already exists it is deleted and the path created
   */


  async ensureFile(file) {
    if (await _fsExtra.default.pathExists(file)) {
      await _fsExtra.default.remove(file);
    }

    await _fsExtra.default.mkdirs(_path.default.dirname(file));
  }
  /**
   * Checks if the specified binaries exist, which are required for the maker to be used.
   */


  externalBinariesExist() {
    return this.requiredExternalBinaries.every(binary => _which.default.sync(binary, {
      nothrow: true
    }) !== null);
  }
  /**
   * Throws an error if any of the binaries don't exist.
   */


  ensureExternalBinariesExist() {
    if (!this.externalBinariesExist()) {
      throw new Error(`Cannot make for ${this.name}, the following external binaries need to be installed: ${this.requiredExternalBinaries.join(', ')}`);
    }
  }
  /**
   * Checks if the given module is installed, used for testing if optional dependencies
   * are installed or not
   */


  isInstalled(module) {
    try {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      require(module);

      return true;
    } catch (e) {
      // Package doesn't exist -- must not be installable on this platform
      return false;
    }
  }
  /**
   * Normalize the given semver-formatted version to a 4-part dot delimited version number without
   * prerelease information for use in Windows apps.
   */


  normalizeWindowsVersion(version) {
    const noPrerelease = version.replace(/-.*/, '');
    return `${noPrerelease}.0`;
  }

}

exports.default = Maker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlci50cyJdLCJuYW1lcyI6WyJNYWtlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnRmV0Y2hlciIsInByb3ZpZGVkUGxhdGZvcm1zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJwbGF0Zm9ybXMiLCJkZWZhdWx0UGxhdGZvcm1zIiwicHJlcGFyZUNvbmZpZyIsInRhcmdldEFyY2giLCJjb25maWciLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwicHJvdG90eXBlIiwiRXJyb3IiLCJuYW1lIiwibWFrZSIsIm9wdHMiLCJlbnN1cmVEaXJlY3RvcnkiLCJkaXIiLCJmcyIsInBhdGhFeGlzdHMiLCJyZW1vdmUiLCJta2RpcnMiLCJlbnN1cmVGaWxlIiwiZmlsZSIsInBhdGgiLCJkaXJuYW1lIiwiZXh0ZXJuYWxCaW5hcmllc0V4aXN0IiwicmVxdWlyZWRFeHRlcm5hbEJpbmFyaWVzIiwiZXZlcnkiLCJiaW5hcnkiLCJ3aGljaCIsInN5bmMiLCJub3Rocm93IiwiZW5zdXJlRXh0ZXJuYWxCaW5hcmllc0V4aXN0Iiwiam9pbiIsImlzSW5zdGFsbGVkIiwibW9kdWxlIiwicmVxdWlyZSIsImUiLCJub3JtYWxpemVXaW5kb3dzVmVyc2lvbiIsInZlcnNpb24iLCJub1ByZXJlbGVhc2UiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBb0NlLE1BQWVBLEtBQWYsQ0FBK0M7QUFXNURDLEVBQUFBLFdBQVcsQ0FBU0MsYUFBMkMsR0FBRyxFQUF2RCxFQUEwRUMsaUJBQTFFLEVBQStHO0FBQUEsU0FBdEdELGFBQXNHLEdBQXRHQSxhQUFzRztBQUFBLFNBQXJDQyxpQkFBcUMsR0FBckNBLGlCQUFxQzs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQSxzREFKOUUsRUFJOEU7O0FBQUE7O0FBQ3hIQyxJQUFBQSxNQUFNLENBQUNDLGNB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QVA7QUFDRCxLQUpELENBSUUsT0FBT0UsQ0FBUCxFQUFVO0FBQ1Y7QUFDQSxhQUFPLEtBQVA7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7OztBQUNFQyxFQUFBQSx1QkFBdUIsQ0FBQ0MsT0FBRCxFQUEwQjtBQUMvQyxVQUFNQyxZQUFZLEdBQUdELE9BQU8sQ0FBQ0UsT0FBUixDQUFnQixLQUFoQixFQUF1QixFQUF2QixDQUFyQjtBQUNBLFdBQVEsR0FBRUQsWUFBYSxJQUF2QjtBQUNEOztBQWpJMkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGb3JnZUFyY2gsIEZvcmdlQ29uZmlnLCBGb3JnZVBsYXRmb3JtLCBJRm9yZ2VNYWtlciB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHdoaWNoIGZyb20gJ3doaWNoJztcblxuZXhwb3J0IHR5cGUgRW1wdHlDb25maWcgPSBSZWNvcmQ8c3RyaW5nLCBuZXZlcj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFrZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgcGFja2FnZWQgRWxlY3Ryb24gYXBwbGljYXRpb25cbiAgICovXG4gIGRpcjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGRpcmVjdG9yeSB5b3Ugc2hvdWxkIHB1dCBhbGwgeW91ciBhcnRpZmFjdHMgaW4gKHBvdGVudGlhbGx5IGluIHN1YiBmb2xkZXJzKVxuICAgKiBOT1RFOiB0aGlzIGRpcmVjdG9yeSBpcyBub3QgZ3VhcnVudGVlZCB0byBhbHJlYWR5IGV4aXN0XG4gICAqL1xuICBtYWtlRGlyOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgaHVtYW4gZnJpZW5kbHkgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgYXBwTmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBwbGF0Zm9ybSB5b3Ugc2hvdWxkIG1ha2UgZm9yXG4gICAqL1xuICB0YXJnZXRQbGF0Zm9ybTogRm9yZ2VQbGF0Zm9ybTtcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgYXJjaGl0ZWN0dXJlIHlvdSBzaG91bGQgbWFrZSBmb3JcbiAgICovXG4gIHRhcmdldEFyY2g6IEZvcmdlQXJjaDtcbiAgLyoqXG4gICAqIEZ1bGx5IHJlc29sdmVkIGZvcmdlIGNvbmZpZ3VyYXRpb24sIHlvdSBzaG91bGRuJ3QgcmVhbGx5IG5lZWQgdGhpc1xuICAgKi9cbiAgZm9yZ2VDb25maWc6IEZvcmdlQ29uZmlnO1xuICAvKipcbiAgICogVGhlIGFwcGxpY2F0aW9uJ3MgcGFja2FnZS5qc29uIGZpbGVcbiAgICovXG4gIHBhY2thZ2VKU09OOiBhbnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxufVxuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBNYWtlcjxDPiBpbXBsZW1lbnRzIElGb3JnZU1ha2VyIHtcbiAgcHVibGljIGNvbmZpZyE6IEM7XG5cbiAgcHVibGljIGFic3RyYWN0IG5hbWU6IHN0cmluZztcblxuICBwdWJsaWMgYWJzdHJhY3QgZGVmYXVsdFBsYXRmb3JtczogRm9yZ2VQbGF0Zm9ybVtdO1xuXG4gIHB1YmxpYyByZXF1aXJlZEV4dGVybmFsQmluYXJpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgX19pc0VsZWN0cm9uRm9yZ2VNYWtlciE6IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb25maWdGZXRjaGVyOiBDIHwgKChhcmNoOiBGb3JnZUFyY2gpID0+IEMpID0ge30gYXMgQywgcHJvdGVjdGVkIHByb3ZpZGVkUGxhdGZvcm1zPzogRm9yZ2VQbGF0Zm9ybVtdKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyJywge1xuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBnZXQgcGxhdGZvcm1zKCk6IEZvcmdlUGxhdGZvcm1bXSB7XG4gICAgaWYgKHRoaXMucHJvdmlkZWRQbGF0Zm9ybXMpIHJldHVybiB0aGlzLnByb3ZpZGVkUGxhdGZvcm1zO1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRQbGF0Zm9ybXM7XG4gIH1cblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcywgaXQgaXMgYW4gZXllLXNvcmUgYW5kIGlzIGEgbmFzdHkgaGFjayB0byBwcm92aWRlIGZvcmdlXG4gIC8vICAgICAgIHY1IHN0eWxlIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIG5ldyBBUElcbiAgcHJlcGFyZUNvbmZpZyh0YXJnZXRBcmNoOiBGb3JnZUFyY2gpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuY29uZmlnRmV0Y2hlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jb25maWcgPSAodGhpcy5jb25maWdGZXRjaGVyIGFzIHVua25vd24gYXMgKGFyY2g6IEZvcmdlQXJjaCkgPT4gQykodGFyZ2V0QXJjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5jb25maWdGZXRjaGVyIGFzIEM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VycyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCBhbmQgcmV0dXJuIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAqIHRoaXMgbWFrZXIgY2FuIGJlIHJ1biBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybS4gIE5vcm1hbGx5IHRoaXMgaXMganVzdCBhIHByb2Nlc3MucGxhdGZvcm1cbiAgICogY2hlY2sgYnV0IGl0IGNhbiBiZSBhIGRlZXBlciBjaGVjayBmb3IgZGVwZW5kZW5jaWVzIGxpa2UgZmFrZS1yb290IG9yIG90aGVyXG4gICAqIHJlcXVpcmVkIGV4dGVybmFsIGJ1aWxkIHRvb2xzLlxuICAgKlxuICAgKiBJZiB0aGUgaXNzdWUgaXMgYSBtaXNzaW5nIGRlcGVuZGVuY3kgeW91IHNob3VsZCBsb2cgb3V0IGEgSEVMUEZVTCBlcnJvciBtZXNzYWdlXG4gICAqIHRlbGxpbmcgdGhlIGRldmVsb3BlciBleGFjdGx5IHdoYXQgaXMgbWlzc2luZyBhbmQgaWYgcG9zc2libGUgaG93IHRvIGdldCBpdC5cbiAgICovXG4gIGlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0oKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSA9PT0gTWFrZXIucHJvdG90eXBlLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFrZXIgJHt0aGlzLm5hbWV9IGRpZCBub3QgaW1wbGVtZW50IHRoZSBpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIG1ldGhvZGApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcnMgbXVzdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgYW5kIHJldHVybiBhbiBhcnJheSBvZiBhYnNvbHV0ZSBwYXRoc1xuICAgKiB0byB0aGUgYXJ0aWZhY3RzIGdlbmVyYXRlZCBieSB5b3VyIG1ha2VyXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGFzeW5jIG1ha2Uob3B0czogTWFrZXJPcHRpb25zKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGlmICh0aGlzLm1ha2UgPT09IE1ha2VyLnByb3RvdHlwZS5tYWtlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ha2VyICR7dGhpcy5uYW1lfSBkaWQgbm90IGltcGxlbWVudCB0aGUgbWFrZSBtZXRob2RgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGZvcmNlZCB0byBiZSBlbXB0eS5cbiAgICpcbiAgICogSS5lLiBJZiB0aGUgZGlyZWN0b3J5IGFscmVhZHkgZXhpc3RzIGl0IGlzIGRlbGV0ZWQgYW5kIHJlY3JlYXRlZCwgdGhpc1xuICAgKiBpcyBhIGRlc3RydWN0aXZlIG9wZXJhdGlvblxuICAgKi9cbiAgYXN5bmMgZW5zdXJlRGlyZWN0b3J5KGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoZGlyKSkge1xuICAgICAgYXdhaXQgZnMucmVtb3ZlKGRpcik7XG4gICAgfVxuICAgIHJldHVybiBmcy5ta2RpcnMoZGlyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBwYXRoIHRvIHRoZSBmaWxlIGV4aXN0cyBhbmQgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3RcbiAgICpcbiAgICogSS5lLiBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBpdCBpcyBkZWxldGVkIGFuZCB0aGUgcGF0aCBjcmVhdGVkXG4gICAqL1xuICBhc3luYyBlbnN1cmVGaWxlKGZpbGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGZpbGUpKSB7XG4gICAgICBhd2FpdCBmcy5yZW1vdmUoZmlsZSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLm1rZGlycyhwYXRoLmRpcm5hbWUoZmlsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGJpbmFyaWVzIGV4aXN0LCB3aGljaCBhcmUgcmVxdWlyZWQgZm9yIHRoZSBtYWtlciB0byBiZSB1c2VkLlxuICAgKi9cbiAgZXh0ZXJuYWxCaW5hcmllc0V4aXN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllcy5ldmVyeSgoYmluYXJ5KSA9PiB3aGljaC5zeW5jKGJpbmFyeSwgeyBub3Rocm93OiB0cnVlIH0pICE9PSBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBiaW5hcmllcyBkb24ndCBleGlzdC5cbiAgICovXG4gIGVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZXh0ZXJuYWxCaW5hcmllc0V4aXN0KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1ha2UgZm9yICR7dGhpcy5uYW1lfSwgdGhlIGZvbGxvd2luZyBleHRlcm5hbCBiaW5hcmllcyBuZWVkIHRvIGJlIGluc3RhbGxlZDogJHt0aGlzLnJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllcy5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG1vZHVsZSBpcyBpbnN0YWxsZWQsIHVzZWQgZm9yIHRlc3RpbmcgaWYgb3B0aW9uYWwgZGVwZW5kZW5jaWVzXG4gICAqIGFyZSBpbnN0YWxsZWQgb3Igbm90XG4gICAqL1xuICBpc0luc3RhbGxlZChtb2R1bGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICAgIHJlcXVpcmUobW9kdWxlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFBhY2thZ2UgZG9lc24ndCBleGlzdCAtLSBtdXN0IG5vdCBiZSBpbnN0YWxsYWJsZSBvbiB0aGlzIHBsYXRmb3JtXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gc2VtdmVyLWZvcm1hdHRlZCB2ZXJzaW9uIHRvIGEgNC1wYXJ0IGRvdCBkZWxpbWl0ZWQgdmVyc2lvbiBudW1iZXIgd2l0aG91dFxuICAgKiBwcmVyZWxlYXNlIGluZm9ybWF0aW9uIGZvciB1c2UgaW4gV2luZG93cyBhcHBzLlxuICAgKi9cbiAgbm9ybWFsaXplV2luZG93c1ZlcnNpb24odmVyc2lvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBub1ByZXJlbGVhc2UgPSB2ZXJzaW9uLnJlcGxhY2UoLy0uKi8sICcnKTtcbiAgICByZXR1cm4gYCR7bm9QcmVyZWxlYXNlfS4wYDtcbiAgfVxufVxuIl19