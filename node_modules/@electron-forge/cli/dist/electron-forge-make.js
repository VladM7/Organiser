"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMakeOptions = getMakeOptions;

require("source-map-support/register");

var _core = require("@electron-forge/core");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _get = require("@electron/get");

var _commander = _interopRequireDefault(require("commander"));

var _path = _interopRequireDefault(require("path"));

require("./util/terminate");

var _workingDir = _interopRequireDefault(require("./util/working-dir"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/prefer-default-export
async function getMakeOptions() {
  let dir = process.cwd();

  _commander.default.version((await _fsExtra.default.readJson(_path.default.resolve(__dirname, '../package.json'))).version).arguments('[cwd]').option('--skip-package', 'Assume the app is already packaged').option('-a, --arch [arch]', 'Target architecture').option('-p, --platform [platform]', 'Target build platform').option('--targets [targets]', 'Override your make targets for this run').allowUnknownOption(true).action(cwd => {
    dir = (0, _workingDir.default)(dir, cwd);
  }).parse(process.argv);

  const makeOpts = {
    dir,
    interactive: true,
    skipPackage: _commander.default.skipPackage
  };
  if (_commander.default.targets) makeOpts.overrideTargets = _commander.default.targets.split(',');
  if (_commander.default.arch) makeOpts.arch = _commander.default.arch;
  if (_commander.default.platform) makeOpts.platform = _commander.default.platform;
  return makeOpts;
} // eslint-disable-next-line no-underscore-dangle


if (require.main === module || global.__LINKED_FORGE__) {
  (async () => {
    const makeOpts = await getMakeOptions();
    (0, _get.initializeProxy)();
    await _core.api.make(makeOpts);
  })();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lbGVjdHJvbi1mb3JnZS1tYWtlLnRzIl0sIm5hbWVzIjpbImdldE1ha2VPcHRpb25zIiwiZGlyIiwicHJvY2VzcyIsImN3ZCIsInByb2dyYW0iLCJ2ZXJzaW9uIiwiZnMiLCJyZWFkSnNvbiIsInBhdGgiLCJyZXNvbHZlIiwiX19kaXJuYW1lIiwiYXJndW1lbnRzIiwib3B0aW9uIiwiYWxsb3dVbmtub3duT3B0aW9uIiwiYWN0aW9uIiwicGFyc2UiLCJhcmd2IiwibWFrZU9wdHMiLCJpbnRlcmFjdGl2ZSIsInNraXBQYWNrYWdlIiwidGFyZ2V0cyIsIm92ZXJyaWRlVGFyZ2V0cyIsInNwbGl0IiwiYXJjaCIsInBsYXRmb3JtIiwicmVxdWlyZSIsIm1haW4iLCJtb2R1bGUiLCJnbG9iYWwiLCJfX0xJTktFRF9GT1JHRV9fIiwiYXBpIiwibWFrZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFFQTtBQUNPLGVBQWVBLGNBQWYsR0FBZ0M7QUFDckMsTUFBSUMsR0FBRyxHQUFHQyxPQUFPLENBQUNDLEdBQVIsRUFBVjs7QUFDQUMscUJBQ0dDLE9BREgsQ0FDVyxDQUFDLE1BQU1DLGlCQUFHQyxRQUFILENBQVlDLGNBQUtDLE9BQUwsQ0FBYUMsU0FBYixFQUF3QixpQkFBeEIsQ0FBWixDQUFQLEVBQWdFTCxPQUQzRSxFQUVHTSxTQUZILENBRWEsT0FGYixFQUdHQyxNQUhILENBR1UsZ0JBSFYsRUFHNEIsb0NBSDVCLEVBSUdBLE1BSkgsQ0FJVSxtQkFKVixFQUkrQixxQkFKL0IsRUFLR0EsTUFMSCxDQUtVLDJCQUxWLEVBS3VDLHVCQUx2QyxFQU1HQSxNQU5ILENBTVUscUJBTlYsRUFNaUMseUNBTmpDLEVBT0dDLGtCQVBILENBT3NCLElBUHRCLEVBUUdDLE1BUkgsQ0FRV1gsR0FBRCxJQUFTO0FBQUVGLElBQUFBLEdBQUcsR0FBRyx5QkFBV0EsR0FBWCxFQUFnQkUsR0FBaEIsQ0FBTjtBQUE2QixHQVJsRCxFQVNHWSxLQVRILENBU1NiLE9BQU8sQ0FBQ2MsSUFUakI7O0FBV0EsUUFBTUMsUUFBcUIsR0FBRztBQUM1QmhCLElBQUFBLEdBRDRCO0FBRTVCaUIsSUFBQUEsV0FBVyxFQUFFLElBRmU7QUFHNUJDLElBQUFBLFdBQVcsRUFBRWYsbUJBQVFlO0FBSE8sR0FBOUI7QUFLQSxNQUFJZixtQkFBUWdCLE9BQVosRUFBcUJILFFBQVEsQ0FBQ0ksZUFBVCxHQUEyQmpCLG1CQUFRZ0IsT0FBUixDQUFnQkUsS0FBaEIsQ0FBc0IsR0FBdEIsQ0FBM0I7QUFDckIsTUFBSWxCLG1CQUFRbUIsSUFBWixFQUFrQk4sUUFBUSxDQUFDTSxJQUFULEdBQWdCbkIsbUJBQVFtQixJQUF4QjtBQUNsQixNQUFJbkIsbUJBQVFvQixRQUFaLEVBQXNCUCxRQUFRLENBQUNPLFFBQVQsR0FBb0JwQixtQkFBUW9CLFFBQTVCO0FBRXRCLFNBQU9QLFFBQVA7QUFDRCxDLENBRUQ7OztBQUNBLElBQUlRLE9BQU8sQ0FBQ0MsSUFBUixLQUFpQkMsTUFBakIsSUFBNEJDLE1BQUQsQ0FBZ0JDLGdCQUEvQyxFQUFpRTtBQUMvRCxHQUFDLFlBQVk7QUFDWCxVQUFNWixRQUFRLEdBQUcsTUFBTWpCLGNBQWMsRUFBckM7QUFFQTtBQUVBLFVBQU04QixVQUFJQyxJQUFKLENBQVNkLFFBQVQsQ0FBTjtBQUNELEdBTkQ7QUFPRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwaSwgTWFrZU9wdGlvbnMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvY29yZSc7XG5cbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBpbml0aWFsaXplUHJveHkgfSBmcm9tICdAZWxlY3Ryb24vZ2V0JztcbmltcG9ydCBwcm9ncmFtIGZyb20gJ2NvbW1hbmRlcic7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0ICcuL3V0aWwvdGVybWluYXRlJztcbmltcG9ydCB3b3JraW5nRGlyIGZyb20gJy4vdXRpbC93b3JraW5nLWRpcic7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWFrZU9wdGlvbnMoKSB7XG4gIGxldCBkaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICBwcm9ncmFtXG4gICAgLnZlcnNpb24oKGF3YWl0IGZzLnJlYWRKc29uKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi9wYWNrYWdlLmpzb24nKSkpLnZlcnNpb24pXG4gICAgLmFyZ3VtZW50cygnW2N3ZF0nKVxuICAgIC5vcHRpb24oJy0tc2tpcC1wYWNrYWdlJywgJ0Fzc3VtZSB0aGUgYXBwIGlzIGFscmVhZHkgcGFja2FnZWQnKVxuICAgIC5vcHRpb24oJy1hLCAtLWFyY2ggW2FyY2hdJywgJ1RhcmdldCBhcmNoaXRlY3R1cmUnKVxuICAgIC5vcHRpb24oJy1wLCAtLXBsYXRmb3JtIFtwbGF0Zm9ybV0nLCAnVGFyZ2V0IGJ1aWxkIHBsYXRmb3JtJylcbiAgICAub3B0aW9uKCctLXRhcmdldHMgW3RhcmdldHNdJywgJ092ZXJyaWRlIHlvdXIgbWFrZSB0YXJnZXRzIGZvciB0aGlzIHJ1bicpXG4gICAgLmFsbG93VW5rbm93bk9wdGlvbih0cnVlKVxuICAgIC5hY3Rpb24oKGN3ZCkgPT4geyBkaXIgPSB3b3JraW5nRGlyKGRpciwgY3dkKTsgfSlcbiAgICAucGFyc2UocHJvY2Vzcy5hcmd2KTtcblxuICBjb25zdCBtYWtlT3B0czogTWFrZU9wdGlvbnMgPSB7XG4gICAgZGlyLFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHNraXBQYWNrYWdlOiBwcm9ncmFtLnNraXBQYWNrYWdlLFxuICB9O1xuICBpZiAocHJvZ3JhbS50YXJnZXRzKSBtYWtlT3B0cy5vdmVycmlkZVRhcmdldHMgPSBwcm9ncmFtLnRhcmdldHMuc3BsaXQoJywnKTtcbiAgaWYgKHByb2dyYW0uYXJjaCkgbWFrZU9wdHMuYXJjaCA9IHByb2dyYW0uYXJjaDtcbiAgaWYgKHByb2dyYW0ucGxhdGZvcm0pIG1ha2VPcHRzLnBsYXRmb3JtID0gcHJvZ3JhbS5wbGF0Zm9ybTtcblxuICByZXR1cm4gbWFrZU9wdHM7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuaWYgKHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlIHx8IChnbG9iYWwgYXMgYW55KS5fX0xJTktFRF9GT1JHRV9fKSB7XG4gIChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbWFrZU9wdHMgPSBhd2FpdCBnZXRNYWtlT3B0aW9ucygpO1xuXG4gICAgaW5pdGlhbGl6ZVByb3h5KCk7XG5cbiAgICBhd2FpdCBhcGkubWFrZShtYWtlT3B0cyk7XG4gIH0pKCk7XG59XG4iXX0=