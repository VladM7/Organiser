"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = checkSystem;
exports.validPackageManagerVersion = validPackageManagerVersion;

require("source-map-support/register");

var _child_process = require("child_process");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _core = require("@electron-forge/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:check-system');

async function checkGitExists() {
  return new Promise(resolve => {
    (0, _child_process.exec)('git --version', err => resolve(!err));
  });
}

async function checkNodeVersion(ora) {
  const {
    engines
  } = await _fsExtra.default.readJson(_path.default.resolve(__dirname, '..', '..', 'package.json'));

  const versionSatisified = _semver.default.satisfies(process.versions.node, engines.node);

  if (!versionSatisified) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ora.warn(`You are running Node.js version ${process.versions.node}, but Electron Forge requires Node.js ${engines.node}.`);
  }

  return versionSatisified;
}

const NPM_WHITELISTED_VERSIONS = {
  all: '^3.0.0 || ^4.0.0 || ~5.1.0 || ~5.2.0 || >= 5.4.2',
  darwin: '>= 5.4.0',
  linux: '>= 5.4.0'
};
const YARN_WHITELISTED_VERSIONS = {
  all: '0.23.3 || 0.24.6 || >= 1.0.0',
  darwin: '0.27.5',
  linux: '0.27.5'
};

function validPackageManagerVersion(packageManager, version, whitelistedVersions, ora) {
  try {
    return _semver.default.satisfies(version, whitelistedVersions);
  } catch (e) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ora.warn(`Could not check ${packageManager} version "${version}", assuming incompatible`);
    d(`Exception while checking version: ${e}`);
    return false;
  }
}

function warnIfPackageManagerIsntAKnownGoodVersion(packageManager, version, whitelistedVersions, ora) {
  const osVersions = whitelistedVersions[process.platform];
  const versions = osVersions ? `${whitelistedVersions.all} || ${osVersions}` : whitelistedVersions.all;
  const versionString = version.toString();

  if (!validPackageManagerVersion(packageManager, versionString, versions, ora)) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ora.warn(`You are using ${packageManager}, but not a known good version.
The known versions that work with Electron Forge are: ${versions}`);
  }
}

async function checkPackageManagerVersion(ora) {
  const version = await _core.utils.yarnOrNpmSpawn(['--version']);
  const versionString = version.toString();

  if (_core.utils.hasYarn()) {
    warnIfPackageManagerIsntAKnownGoodVersion('Yarn', versionString, YARN_WHITELISTED_VERSIONS, ora);
  } else {
    warnIfPackageManagerIsntAKnownGoodVersion('NPM', versionString, NPM_WHITELISTED_VERSIONS, ora);
  }

  return true;
}
/**
 * Some people know their system is OK and don't appreciate the 800ms lag in
 * start up that these checks (in particular the package manager check) costs.
 *
 * Simply creating this flag file in your home directory will skip these checks
 * and shave ~800ms off your forge start time.
 *
 * This is specifically not documented or everyone would make it.
 */


const SKIP_SYSTEM_CHECK = _path.default.resolve(_os.default.homedir(), '.skip-forge-system-check');

async function checkSystem(ora) {
  if (!(await _fsExtra.default.pathExists(SKIP_SYSTEM_CHECK))) {
    d('checking system, create ~/.skip-forge-system-check to stop doing this');
    return (await Promise.all([checkGitExists(), checkNodeVersion(ora), checkPackageManagerVersion(ora)])).every(check => check);
  }

  d('skipping system check');
  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2NoZWNrLXN5c3RlbS50cyJdLCJuYW1lcyI6WyJkIiwiY2hlY2tHaXRFeGlzdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsImNoZWNrTm9kZVZlcnNpb24iLCJvcmEiLCJlbmdpbmVzIiwiZnMiLCJyZWFkSnNvbiIsInBhdGgiLCJfX2Rpcm5hbWUiLCJ2ZXJzaW9uU2F0aXNpZmllZCIsInNlbXZlciIsInNhdGlzZmllcyIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJ3YXJuIiwiTlBNX1dISVRFTElTVEVEX1ZFUlNJT05TIiwiYWxsIiwiZGFyd2luIiwibGludXgiLCJZQVJOX1dISVRFTElTVEVEX1ZFUlNJT05TIiwidmFsaWRQYWNrYWdlTWFuYWdlclZlcnNpb24iLCJwYWNrYWdlTWFuYWdlciIsInZlcnNpb24iLCJ3aGl0ZWxpc3RlZFZlcnNpb25zIiwiZSIsIndhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uIiwib3NWZXJzaW9ucyIsInBsYXRmb3JtIiwidmVyc2lvblN0cmluZyIsInRvU3RyaW5nIiwiY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24iLCJmb3JnZVV0aWxzIiwieWFybk9yTnBtU3Bhd24iLCJoYXNZYXJuIiwiU0tJUF9TWVNURU1fQ0hFQ0siLCJvcyIsImhvbWVkaXIiLCJjaGVja1N5c3RlbSIsInBhdGhFeGlzdHMiLCJldmVyeSIsImNoZWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFHQSxNQUFNQSxDQUFDLEdBQUcsb0JBQU0sNkJBQU4sQ0FBVjs7QUFFQSxlQUFlQyxjQUFmLEdBQWdDO0FBQzlCLFNBQU8sSUFBSUMsT0FBSixDQUFzQkMsT0FBRCxJQUFhO0FBQ3ZDLDZCQUFLLGVBQUwsRUFBdUJDLEdBQUQsSUFBU0QsT0FBTyxDQUFDLENBQUNDLEdBQUYsQ0FBdEM7QUFDRCxHQUZN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OztBQUVELFNBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNZ0MsaUJBQWlCLEdBQUc1QixjQUFLUCxPQUFMLENBQWFvQyxZQUFHQyxPQUFILEVBQWIsRUFBMkIsMEJBQTNCLENBQTFCOztBQUVlLGVBQWVDLFdBQWYsQ0FBMkJuQyxHQUEzQixFQUEyRDtBQUN4RSxNQUFJLEVBQUUsTUFBTUUsaUJBQUdrQyxVQUFILENBQWNKLGlCQUFkLENBQVIsQ0FBSixFQUErQztBQUM3Q3RDLElBQUFBLENBQUMsQ0FBQyx1RUFBRCxDQUFEO0FBQ0EsV0FBTyxDQUFDLE1BQU1FLE9BQU8sQ0FBQ2tCLEdBQVIsQ0FBWSxDQUFDbkIsY0FBYyxFQUFmLEVBQW1CSSxnQkFBZ0IsQ0FBQ0MsR0FBRCxDQUFuQyxFQUEwQzRCLDBCQUEwQixDQUFDNUIsR0FBRCxDQUFwRSxDQUFaLENBQVAsRUFBZ0dxQyxLQUFoRyxDQUF1R0MsS0FBRCxJQUFXQSxLQUFqSCxDQUFQO0FBQ0Q7O0FBQ0Q1QyxFQUFBQSxDQUFDLENBQUMsdUJBQUQsQ0FBRDtBQUNBLFNBQU8sSUFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmltcG9ydCB7IHV0aWxzIGFzIGZvcmdlVXRpbHMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvY29yZSc7XG5pbXBvcnQgeyBPcmFJbXBsIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2FzeW5jLW9yYSc7XG5cbmNvbnN0IGQgPSBkZWJ1ZygnZWxlY3Ryb24tZm9yZ2U6Y2hlY2stc3lzdGVtJyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrR2l0RXhpc3RzKCkge1xuICByZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcbiAgICBleGVjKCdnaXQgLS12ZXJzaW9uJywgKGVycikgPT4gcmVzb2x2ZSghZXJyKSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja05vZGVWZXJzaW9uKG9yYTogT3JhSW1wbCkge1xuICBjb25zdCB7IGVuZ2luZXMgfSA9IGF3YWl0IGZzLnJlYWRKc29uKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLicsICcuLicsICdwYWNrYWdlLmpzb24nKSk7XG4gIGNvbnN0IHZlcnNpb25TYXRpc2lmaWVkID0gc2VtdmVyLnNhdGlzZmllcyhwcm9jZXNzLnZlcnNpb25zLm5vZGUsIGVuZ2luZXMubm9kZSk7XG5cbiAgaWYgKCF2ZXJzaW9uU2F0aXNpZmllZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgb3JhLndhcm4hKGBZb3UgYXJlIHJ1bm5pbmcgTm9kZS5qcyB2ZXJzaW9uICR7cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfSwgYnV0IEVsZWN0cm9uIEZvcmdlIHJlcXVpcmVzIE5vZGUuanMgJHtlbmdpbmVzLm5vZGV9LmApO1xuICB9XG5cbiAgcmV0dXJuIHZlcnNpb25TYXRpc2lmaWVkO1xufVxuXG5jb25zdCBOUE1fV0hJVEVMSVNURURfVkVSU0lPTlMgPSB7XG4gIGFsbDogJ14zLjAuMCB8fCBeNC4wLjAgfHwgfjUuMS4wIHx8IH41LjIuMCB8fCA+PSA1LjQuMicsXG4gIGRhcndpbjogJz49IDUuNC4wJyxcbiAgbGludXg6ICc+PSA1LjQuMCcsXG59O1xuY29uc3QgWUFSTl9XSElURUxJU1RFRF9WRVJTSU9OUyA9IHtcbiAgYWxsOiAnMC4yMy4zIHx8IDAuMjQuNiB8fCA+PSAxLjAuMCcsXG4gIGRhcndpbjogJzAuMjcuNScsXG4gIGxpbnV4OiAnMC4yNy41Jyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFBhY2thZ2VNYW5hZ2VyVmVyc2lvbihwYWNrYWdlTWFuYWdlcjogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIHdoaXRlbGlzdGVkVmVyc2lvbnM6IHN0cmluZywgb3JhOiBPcmFJbXBsKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXModmVyc2lvbiwgd2hpdGVsaXN0ZWRWZXJzaW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIG9yYS53YXJuIShgQ291bGQgbm90IGNoZWNrICR7cGFja2FnZU1hbmFnZXJ9IHZlcnNpb24gXCIke3ZlcnNpb259XCIsIGFzc3VtaW5nIGluY29tcGF0aWJsZWApO1xuICAgIGQoYEV4Y2VwdGlvbiB3aGlsZSBjaGVja2luZyB2ZXJzaW9uOiAke2V9YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uKHBhY2thZ2VNYW5hZ2VyOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZywgd2hpdGVsaXN0ZWRWZXJzaW9uczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSwgb3JhOiBPcmFJbXBsKSB7XG4gIGNvbnN0IG9zVmVyc2lvbnMgPSB3aGl0ZWxpc3RlZFZlcnNpb25zW3Byb2Nlc3MucGxhdGZvcm1dO1xuICBjb25zdCB2ZXJzaW9ucyA9IG9zVmVyc2lvbnMgPyBgJHt3aGl0ZWxpc3RlZFZlcnNpb25zLmFsbH0gfHwgJHtvc1ZlcnNpb25zfWAgOiB3aGl0ZWxpc3RlZFZlcnNpb25zLmFsbDtcbiAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKTtcbiAgaWYgKCF2YWxpZFBhY2thZ2VNYW5hZ2VyVmVyc2lvbihwYWNrYWdlTWFuYWdlciwgdmVyc2lvblN0cmluZywgdmVyc2lvbnMsIG9yYSkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIG9yYS53YXJuIShgWW91IGFyZSB1c2luZyAke3BhY2thZ2VNYW5hZ2VyfSwgYnV0IG5vdCBhIGtub3duIGdvb2QgdmVyc2lvbi5cblRoZSBrbm93biB2ZXJzaW9ucyB0aGF0IHdvcmsgd2l0aCBFbGVjdHJvbiBGb3JnZSBhcmU6ICR7dmVyc2lvbnN9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24ob3JhOiBPcmFJbXBsKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBhd2FpdCBmb3JnZVV0aWxzLnlhcm5Pck5wbVNwYXduKFsnLS12ZXJzaW9uJ10pO1xuICBjb25zdCB2ZXJzaW9uU3RyaW5nID0gdmVyc2lvbi50b1N0cmluZygpO1xuICBpZiAoZm9yZ2VVdGlscy5oYXNZYXJuKCkpIHtcbiAgICB3YXJuSWZQYWNrYWdlTWFuYWdlcklzbnRBS25vd25Hb29kVmVyc2lvbignWWFybicsIHZlcnNpb25TdHJpbmcsIFlBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMsIG9yYSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybklmUGFja2FnZU1hbmFnZXJJc250QUtub3duR29vZFZlcnNpb24oJ05QTScsIHZlcnNpb25TdHJpbmcsIE5QTV9XSElURUxJU1RFRF9WRVJTSU9OUywgb3JhKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFNvbWUgcGVvcGxlIGtub3cgdGhlaXIgc3lzdGVtIGlzIE9LIGFuZCBkb24ndCBhcHByZWNpYXRlIHRoZSA4MDBtcyBsYWcgaW5cbiAqIHN0YXJ0IHVwIHRoYXQgdGhlc2UgY2hlY2tzIChpbiBwYXJ0aWN1bGFyIHRoZSBwYWNrYWdlIG1hbmFnZXIgY2hlY2spIGNvc3RzLlxuICpcbiAqIFNpbXBseSBjcmVhdGluZyB0aGlzIGZsYWcgZmlsZSBpbiB5b3VyIGhvbWUgZGlyZWN0b3J5IHdpbGwgc2tpcCB0aGVzZSBjaGVja3NcbiAqIGFuZCBzaGF2ZSB+ODAwbXMgb2ZmIHlvdXIgZm9yZ2Ugc3RhcnQgdGltZS5cbiAqXG4gKiBUaGlzIGlzIHNwZWNpZmljYWxseSBub3QgZG9jdW1lbnRlZCBvciBldmVyeW9uZSB3b3VsZCBtYWtlIGl0LlxuICovXG5jb25zdCBTS0lQX1NZU1RFTV9DSEVDSyA9IHBhdGgucmVzb2x2ZShvcy5ob21lZGlyKCksICcuc2tpcC1mb3JnZS1zeXN0ZW0tY2hlY2snKTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY2hlY2tTeXN0ZW0ob3JhOiBPcmFJbXBsKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMoU0tJUF9TWVNURU1fQ0hFQ0spKSkge1xuICAgIGQoJ2NoZWNraW5nIHN5c3RlbSwgY3JlYXRlIH4vLnNraXAtZm9yZ2Utc3lzdGVtLWNoZWNrIHRvIHN0b3AgZG9pbmcgdGhpcycpO1xuICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW2NoZWNrR2l0RXhpc3RzKCksIGNoZWNrTm9kZVZlcnNpb24ob3JhKSwgY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24ob3JhKV0pKS5ldmVyeSgoY2hlY2spID0+IGNoZWNrKTtcbiAgfVxuICBkKCdza2lwcGluZyBzeXN0ZW0gY2hlY2snKTtcbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=