"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validPackageManagerVersion = validPackageManagerVersion;
exports.default = checkSystem;

require("source-map-support/register");

var _child_process = require("child_process");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _core = require("@electron-forge/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:check-system');

async function checkGitExists() {
  return new Promise(resolve => {
    (0, _child_process.exec)('git --version', err => resolve(!err));
  });
}

async function checkNodeVersion(ora) {
  const {
    engines
  } = await _fsExtra.default.readJson(_path.default.resolve(__dirname, '..', '..', 'package.json'));

  const versionSatisified = _semver.default.satisfies(process.versions.node, engines.node);

  if (!versionSatisified) {
    ora.warn(`You are running Node.js version ${process.versions.node}, but Electron Forge requires Node.js ${engines.node}.`);
  }

  return versionSatisified;
}

const NPM_WHITELISTED_VERSIONS = {
  all: '^3.0.0 || ^4.0.0 || ~5.1.0 || ~5.2.0 || >= 5.4.2',
  darwin: '>= 5.4.0',
  linux: '>= 5.4.0'
};
const YARN_WHITELISTED_VERSIONS = {
  all: '0.23.3 || 0.24.6 || >= 1.0.0',
  darwin: '0.27.5',
  linux: '0.27.5'
};

function validPackageManagerVersion(packageManager, version, whitelistedVersions, ora) {
  try {
    return _semver.default.satisfies(version, whitelistedVersions);
  } catch (e) {
    ora.warn(`Could not check ${packageManager} version "${version}", assuming incompatible`);
    d(`Exception while checking version: ${e}`);
    return false;
  }
}

function warnIfPackageManagerIsntAKnownGoodVersion(packageManager, version, whitelistedVersions, ora) {
  const osVersions = whitelistedVersions[process.platform];
  const versions = osVersions ? `${whitelistedVersions.all} || ${osVersions}` : whitelistedVersions.all;
  const versionString = version.toString();

  if (!validPackageManagerVersion(packageManager, versionString, versions, ora)) {
    ora.warn(`You are using ${packageManager}, but not a known good version.
The known versions that work with Electron Forge are: ${versions}`);
  }
}

async function checkPackageManagerVersion(ora) {
  const version = await _core.utils.yarnOrNpmSpawn(['--version']);
  const versionString = version.toString();

  if (_core.utils.hasYarn()) {
    warnIfPackageManagerIsntAKnownGoodVersion('Yarn', versionString, YARN_WHITELISTED_VERSIONS, ora);
  } else {
    warnIfPackageManagerIsntAKnownGoodVersion('NPM', versionString, NPM_WHITELISTED_VERSIONS, ora);
  }

  return true;
}
/**
 * Some people know their system is OK and don't appreciate the 800ms lag in
 * start up that these checks (in particular the package manager check) costs.
 *
 * Simply creating this flag file in your home directory will skip these checks
 * and shave ~800ms off your forge start time.
 *
 * This is specifically not documented or everyone would make it.
 */


const SKIP_SYSTEM_CHECK = _path.default.resolve(_os.default.homedir(), '.skip-forge-system-check');

async function checkSystem(ora) {
  if (!(await _fsExtra.default.pathExists(SKIP_SYSTEM_CHECK))) {
    d('checking system, create ~/.skip-forge-system-check to stop doing this');
    return (await Promise.all([checkGitExists(), checkNodeVersion(ora), checkPackageManagerVersion(ora)])).every(check => check);
  }

  d('skipping system check');
  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2NoZWNrLXN5c3RlbS50cyJdLCJuYW1lcyI6WyJkIiwiY2hlY2tHaXRFeGlzdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsImNoZWNrTm9kZVZlcnNpb24iLCJvcmEiLCJlbmdpbmVzIiwiZnMiLCJyZWFkSnNvbiIsInBhdGgiLCJfX2Rpcm5hbWUiLCJ2ZXJzaW9uU2F0aXNpZmllZCIsInNlbXZlciIsInNhdGlzZmllcyIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJ3YXJuIiwiTlBNX1dISVRFTElTVEVEX1ZFUlNJT05TIiwiYWxsIiwiZGFyd2luIiwibGludXgiLCJZQVJOX1dISVRFTElTVEVEX1ZFUlNJT05TIiwidmFsaWRQYWNrYWdlTWFuYWdlclZlcnNpb24iLCJwYWNrYWdlTWFuYWdlciIsInZlcnNpb24iLCJ3aGl0ZWxpc3RlZFZlcnNpb25zIiwiZSIsIndhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uIiwib3NWZXJzaW9ucyIsInBsYXRmb3JtIiwidmVyc2lvblN0cmluZyIsInRvU3RyaW5nIiwiY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24iLCJmb3JnZVV0aWxzIiwieWFybk9yTnBtU3Bhd24iLCJoYXNZYXJuIiwiU0tJUF9TWVNURU1fQ0hFQ0siLCJvcyIsImhvbWVkaXIiLCJjaGVja1N5c3RlbSIsInBhdGhFeGlzdHMiLCJldmVyeSIsImNoZWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFHQSxNQUFNQSxDQUFDLEdBQUcsb0JBQU0sNkJBQU4sQ0FBVjs7QUFFQSxlQUFlQyxjQUFmLEdBQWdDO0FBQzlCLFNBQU8sSUFBSUMsT0FBSixDQUFzQkMsT0FBRCxJQUFhO0FBQ3ZDLDZCQUFLLGVBQUwsRUFBdUJDLEdBQUQsSUFBU0QsT0FBTyxDQUFDLENBQUNDLEdBQUYsQ0FBdEM7QUFDRCxHQUZN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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTWdDLGlCQUFpQixHQUFHNUIsY0FBS1AsT0FBTCxDQUFhb0MsWUFBR0MsT0FBSCxFQUFiLEVBQTJCLDBCQUEzQixDQUExQjs7QUFFZSxlQUFlQyxXQUFmLENBQTJCbkMsR0FBM0IsRUFBMkQ7QUFDeEUsTUFBSSxFQUFDLE1BQU1FLGlCQUFHa0MsVUFBSCxDQUFjSixpQkFBZCxDQUFQLENBQUosRUFBNkM7QUFDM0N0QyxJQUFBQSxDQUFDLENBQUMsdUVBQUQsQ0FBRDtBQUNBLFdBQU8sQ0FBQyxNQUFNRSxPQUFPLENBQUNrQixHQUFSLENBQVksQ0FDeEJuQixjQUFjLEVBRFUsRUFFeEJJLGdCQUFnQixDQUFDQyxHQUFELENBRlEsRUFHeEI0QiwwQkFBMEIsQ0FBQzVCLEdBQUQsQ0FIRixDQUFaLENBQVAsRUFJSHFDLEtBSkcsQ0FJSUMsS0FBRCxJQUFXQSxLQUpkLENBQVA7QUFLRDs7QUFDRDVDLEVBQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFEO0FBQ0EsU0FBTyxJQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuaW1wb3J0IHsgdXRpbHMgYXMgZm9yZ2VVdGlscyB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9jb3JlJztcbmltcG9ydCB7IE9yYUltcGwgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTpjaGVjay1zeXN0ZW0nKTtcblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tHaXRFeGlzdHMoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSkgPT4ge1xuICAgIGV4ZWMoJ2dpdCAtLXZlcnNpb24nLCAoZXJyKSA9PiByZXNvbHZlKCFlcnIpKTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrTm9kZVZlcnNpb24ob3JhOiBPcmFJbXBsKSB7XG4gIGNvbnN0IHsgZW5naW5lcyB9ID0gYXdhaXQgZnMucmVhZEpzb24ocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJ3BhY2thZ2UuanNvbicpKTtcbiAgY29uc3QgdmVyc2lvblNhdGlzaWZpZWQgPSBzZW12ZXIuc2F0aXNmaWVzKHByb2Nlc3MudmVyc2lvbnMubm9kZSwgZW5naW5lcy5ub2RlKTtcblxuICBpZiAoIXZlcnNpb25TYXRpc2lmaWVkKSB7XG4gICAgb3JhLndhcm4hKGBZb3UgYXJlIHJ1bm5pbmcgTm9kZS5qcyB2ZXJzaW9uICR7cHJvY2Vzcy52ZXJzaW9ucy5ub2RlfSwgYnV0IEVsZWN0cm9uIEZvcmdlIHJlcXVpcmVzIE5vZGUuanMgJHtlbmdpbmVzLm5vZGV9LmApO1xuICB9XG5cbiAgcmV0dXJuIHZlcnNpb25TYXRpc2lmaWVkO1xufVxuXG5jb25zdCBOUE1fV0hJVEVMSVNURURfVkVSU0lPTlMgPSB7XG4gIGFsbDogJ14zLjAuMCB8fCBeNC4wLjAgfHwgfjUuMS4wIHx8IH41LjIuMCB8fCA+PSA1LjQuMicsXG4gIGRhcndpbjogJz49IDUuNC4wJyxcbiAgbGludXg6ICc+PSA1LjQuMCcsXG59O1xuY29uc3QgWUFSTl9XSElURUxJU1RFRF9WRVJTSU9OUyA9IHtcbiAgYWxsOiAnMC4yMy4zIHx8IDAuMjQuNiB8fCA+PSAxLjAuMCcsXG4gIGRhcndpbjogJzAuMjcuNScsXG4gIGxpbnV4OiAnMC4yNy41Jyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFBhY2thZ2VNYW5hZ2VyVmVyc2lvbihcbiAgcGFja2FnZU1hbmFnZXI6IHN0cmluZyxcbiAgdmVyc2lvbjogc3RyaW5nLFxuICB3aGl0ZWxpc3RlZFZlcnNpb25zOiBzdHJpbmcsXG4gIG9yYTogT3JhSW1wbCxcbikge1xuICB0cnkge1xuICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb24sIHdoaXRlbGlzdGVkVmVyc2lvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3JhLndhcm4hKGBDb3VsZCBub3QgY2hlY2sgJHtwYWNrYWdlTWFuYWdlcn0gdmVyc2lvbiBcIiR7dmVyc2lvbn1cIiwgYXNzdW1pbmcgaW5jb21wYXRpYmxlYCk7XG4gICAgZChgRXhjZXB0aW9uIHdoaWxlIGNoZWNraW5nIHZlcnNpb246ICR7ZX1gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmUGFja2FnZU1hbmFnZXJJc250QUtub3duR29vZFZlcnNpb24oXG4gIHBhY2thZ2VNYW5hZ2VyOiBzdHJpbmcsXG4gIHZlcnNpb246IHN0cmluZyxcbiAgd2hpdGVsaXN0ZWRWZXJzaW9uczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgb3JhOiBPcmFJbXBsLFxuKSB7XG4gIGNvbnN0IG9zVmVyc2lvbnMgPSB3aGl0ZWxpc3RlZFZlcnNpb25zW3Byb2Nlc3MucGxhdGZvcm1dO1xuICBjb25zdCB2ZXJzaW9ucyA9IG9zVmVyc2lvbnMgPyBgJHt3aGl0ZWxpc3RlZFZlcnNpb25zLmFsbH0gfHwgJHtvc1ZlcnNpb25zfWAgOiB3aGl0ZWxpc3RlZFZlcnNpb25zLmFsbDtcbiAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKTtcbiAgaWYgKCF2YWxpZFBhY2thZ2VNYW5hZ2VyVmVyc2lvbihwYWNrYWdlTWFuYWdlciwgdmVyc2lvblN0cmluZywgdmVyc2lvbnMsIG9yYSkpIHtcbiAgICBvcmEud2FybiEoYFlvdSBhcmUgdXNpbmcgJHtwYWNrYWdlTWFuYWdlcn0sIGJ1dCBub3QgYSBrbm93biBnb29kIHZlcnNpb24uXG5UaGUga25vd24gdmVyc2lvbnMgdGhhdCB3b3JrIHdpdGggRWxlY3Ryb24gRm9yZ2UgYXJlOiAke3ZlcnNpb25zfWApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrUGFja2FnZU1hbmFnZXJWZXJzaW9uKG9yYTogT3JhSW1wbCkge1xuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZm9yZ2VVdGlscy55YXJuT3JOcG1TcGF3bihbJy0tdmVyc2lvbiddKTtcbiAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKTtcbiAgaWYgKGZvcmdlVXRpbHMuaGFzWWFybigpKSB7XG4gICAgd2FybklmUGFja2FnZU1hbmFnZXJJc250QUtub3duR29vZFZlcnNpb24oJ1lhcm4nLCB2ZXJzaW9uU3RyaW5nLCBZQVJOX1dISVRFTElTVEVEX1ZFUlNJT05TLCBvcmEpO1xuICB9IGVsc2Uge1xuICAgIHdhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uKCdOUE0nLCB2ZXJzaW9uU3RyaW5nLCBOUE1fV0hJVEVMSVNURURfVkVSU0lPTlMsIG9yYSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBTb21lIHBlb3BsZSBrbm93IHRoZWlyIHN5c3RlbSBpcyBPSyBhbmQgZG9uJ3QgYXBwcmVjaWF0ZSB0aGUgODAwbXMgbGFnIGluXG4gKiBzdGFydCB1cCB0aGF0IHRoZXNlIGNoZWNrcyAoaW4gcGFydGljdWxhciB0aGUgcGFja2FnZSBtYW5hZ2VyIGNoZWNrKSBjb3N0cy5cbiAqXG4gKiBTaW1wbHkgY3JlYXRpbmcgdGhpcyBmbGFnIGZpbGUgaW4geW91ciBob21lIGRpcmVjdG9yeSB3aWxsIHNraXAgdGhlc2UgY2hlY2tzXG4gKiBhbmQgc2hhdmUgfjgwMG1zIG9mZiB5b3VyIGZvcmdlIHN0YXJ0IHRpbWUuXG4gKlxuICogVGhpcyBpcyBzcGVjaWZpY2FsbHkgbm90IGRvY3VtZW50ZWQgb3IgZXZlcnlvbmUgd291bGQgbWFrZSBpdC5cbiAqL1xuY29uc3QgU0tJUF9TWVNURU1fQ0hFQ0sgPSBwYXRoLnJlc29sdmUob3MuaG9tZWRpcigpLCAnLnNraXAtZm9yZ2Utc3lzdGVtLWNoZWNrJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrU3lzdGVtKG9yYTogT3JhSW1wbCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBpZiAoIWF3YWl0IGZzLnBhdGhFeGlzdHMoU0tJUF9TWVNURU1fQ0hFQ0spKSB7XG4gICAgZCgnY2hlY2tpbmcgc3lzdGVtLCBjcmVhdGUgfi8uc2tpcC1mb3JnZS1zeXN0ZW0tY2hlY2sgdG8gc3RvcCBkb2luZyB0aGlzJyk7XG4gICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBjaGVja0dpdEV4aXN0cygpLFxuICAgICAgY2hlY2tOb2RlVmVyc2lvbihvcmEpLFxuICAgICAgY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24ob3JhKSxcbiAgICBdKSkuZXZlcnkoKGNoZWNrKSA9PiBjaGVjayk7XG4gIH1cbiAgZCgnc2tpcHBpbmcgc3lzdGVtIGNoZWNrJyk7XG4gIHJldHVybiB0cnVlO1xufVxuIl19