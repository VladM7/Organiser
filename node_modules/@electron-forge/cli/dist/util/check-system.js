"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validPackageManagerVersion = validPackageManagerVersion;
exports.default = checkSystem;

require("source-map-support/register");

var _child_process = require("child_process");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _core = require("@electron-forge/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:check-system');

async function checkGitExists() {
  return new Promise(resolve => {
    (0, _child_process.exec)('git --version', err => resolve(!err));
  });
}

async function checkNodeVersion() {
  return Promise.resolve(_semver.default.gt(process.versions.node, '6.0.0'));
}

const NPM_WHITELISTED_VERSIONS = {
  all: '^3.0.0 || ^4.0.0 || ~5.1.0 || ~5.2.0 || >= 5.4.2',
  darwin: '>= 5.4.0',
  linux: '>= 5.4.0'
};
const YARN_WHITELISTED_VERSIONS = {
  all: '0.23.3 || 0.24.6 || >= 1.0.0',
  darwin: '0.27.5',
  linux: '0.27.5'
};

function validPackageManagerVersion(packageManager, version, whitelistedVersions, ora) {
  try {
    return _semver.default.satisfies(version, whitelistedVersions);
  } catch (e) {
    ora.warn(`Could not check ${packageManager} version "${version}", assuming incompatible`);
    d(`Exception while checking version: ${e}`);
    return false;
  }
}

function warnIfPackageManagerIsntAKnownGoodVersion(packageManager, version, whitelistedVersions, ora) {
  const osVersions = whitelistedVersions[process.platform];
  const versions = osVersions ? `${whitelistedVersions.all} || ${osVersions}` : whitelistedVersions.all;
  const versionString = version.toString();

  if (!validPackageManagerVersion(packageManager, versionString, versions, ora)) {
    ora.warn(`You are using ${packageManager}, but not a known good version.
The known versions that work with Electron Forge are: ${versions}`);
  }
}

async function checkPackageManagerVersion(ora) {
  return _core.utils.yarnOrNpmSpawn(['--version']).then(version => {
    const versionString = version.toString();

    if (_core.utils.hasYarn()) {
      warnIfPackageManagerIsntAKnownGoodVersion('Yarn', versionString, YARN_WHITELISTED_VERSIONS, ora);
    } else {
      warnIfPackageManagerIsntAKnownGoodVersion('NPM', versionString, NPM_WHITELISTED_VERSIONS, ora);
    }

    return true;
  });
}
/**
 * Some people know their system is OK and don't appreciate the 800ms lag in
 * start up that these checks (in particular the package manager check) costs.
 *
 * Simply creating this flag file in your home directory will skip these checks
 * and shave ~800ms off your forge start time.
 *
 * This is specifically not documented or everyone would make it.
 */


const SKIP_SYSTEM_CHECK = _path.default.resolve(_os.default.homedir(), '.skip-forge-system-check');

async function checkSystem(ora) {
  if (!(await _fsExtra.default.pathExists(SKIP_SYSTEM_CHECK))) {
    d('checking system, create ~/.skip-forge-system-check to stop doing this');
    return (await Promise.all([checkGitExists(), checkNodeVersion(), checkPackageManagerVersion(ora)])).every(check => check);
  }

  d('skipping system check');
  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2NoZWNrLXN5c3RlbS50cyJdLCJuYW1lcyI6WyJkIiwiY2hlY2tHaXRFeGlzdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsImNoZWNrTm9kZVZlcnNpb24iLCJzZW12ZXIiLCJndCIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJOUE1fV0hJVEVMSVNURURfVkVSU0lPTlMiLCJhbGwiLCJkYXJ3aW4iLCJsaW51eCIsIllBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMiLCJ2YWxpZFBhY2thZ2VNYW5hZ2VyVmVyc2lvbiIsInBhY2thZ2VNYW5hZ2VyIiwidmVyc2lvbiIsIndoaXRlbGlzdGVkVmVyc2lvbnMiLCJvcmEiLCJzYXRpc2ZpZXMiLCJlIiwid2FybiIsIndhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uIiwib3NWZXJzaW9ucyIsInBsYXRmb3JtIiwidmVyc2lvblN0cmluZyIsInRvU3RyaW5nIiwiY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24iLCJmb3JnZVV0aWxzIiwieWFybk9yTnBtU3Bhd24iLCJ0aGVuIiwiaGFzWWFybiIsIlNLSVBfU1lTVEVNX0NIRUNLIiwicGF0aCIsIm9zIiwiaG9tZWRpciIsImNoZWNrU3lzdGVtIiwiZnMiLCJwYXRoRXhpc3RzIiwiZXZlcnkiLCJjaGVjayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBR0EsTUFBTUEsQ0FBQyxHQUFHLG9CQUFNLDZCQUFOLENBQVY7O0FBRUEsZUFBZUMsY0FBZixHQUFnQztBQUM5QixTQUFPLElBQUlDLE9BQUosQ0FBc0JDLE9BQUQsSUFBYTtBQUN2Qyw2QkFBSyxlQUFMLEVBQXVCQyxHQUFELElBQVNELE9BQU8sQ0FBQyxDQUFDQyxHQUFGLENBQXRDO0FBQ0QsR0FGTSxDQUFQO0FBR0Q7O0FBRUQsZUFBZUMsZ0JBQWYsR0FBa0M7QUFDaEMs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QkFBZ0IsRUFGUSxFQUd4QndCLDBCQUEwQixDQUFDVCxHQUFELENBSEYsQ0FBWixDQUFQLEVBSUhxQixLQUpHLENBSUlDLEtBQUQsSUFBV0EsS0FKZCxDQUFQO0FBS0Q7O0FBQ0QxQyxFQUFBQSxDQUFDLENBQUMsdUJBQUQsQ0FBRDtBQUNBLFNBQU8sSUFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmltcG9ydCB7IHV0aWxzIGFzIGZvcmdlVXRpbHMgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvY29yZSc7XG5pbXBvcnQgeyBPcmFJbXBsIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2FzeW5jLW9yYSc7XG5cbmNvbnN0IGQgPSBkZWJ1ZygnZWxlY3Ryb24tZm9yZ2U6Y2hlY2stc3lzdGVtJyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrR2l0RXhpc3RzKCkge1xuICByZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpID0+IHtcbiAgICBleGVjKCdnaXQgLS12ZXJzaW9uJywgKGVycikgPT4gcmVzb2x2ZSghZXJyKSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja05vZGVWZXJzaW9uKCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbXZlci5ndChwcm9jZXNzLnZlcnNpb25zLm5vZGUsICc2LjAuMCcpKTtcbn1cblxuY29uc3QgTlBNX1dISVRFTElTVEVEX1ZFUlNJT05TID0ge1xuICBhbGw6ICdeMy4wLjAgfHwgXjQuMC4wIHx8IH41LjEuMCB8fCB+NS4yLjAgfHwgPj0gNS40LjInLFxuICBkYXJ3aW46ICc+PSA1LjQuMCcsXG4gIGxpbnV4OiAnPj0gNS40LjAnLFxufTtcbmNvbnN0IFlBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMgPSB7XG4gIGFsbDogJzAuMjMuMyB8fCAwLjI0LjYgfHwgPj0gMS4wLjAnLFxuICBkYXJ3aW46ICcwLjI3LjUnLFxuICBsaW51eDogJzAuMjcuNScsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRQYWNrYWdlTWFuYWdlclZlcnNpb24oXG4gIHBhY2thZ2VNYW5hZ2VyOiBzdHJpbmcsXG4gIHZlcnNpb246IHN0cmluZyxcbiAgd2hpdGVsaXN0ZWRWZXJzaW9uczogc3RyaW5nLFxuICBvcmE6IE9yYUltcGwsXG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc2VtdmVyLnNhdGlzZmllcyh2ZXJzaW9uLCB3aGl0ZWxpc3RlZFZlcnNpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG9yYS53YXJuIShgQ291bGQgbm90IGNoZWNrICR7cGFja2FnZU1hbmFnZXJ9IHZlcnNpb24gXCIke3ZlcnNpb259XCIsIGFzc3VtaW5nIGluY29tcGF0aWJsZWApO1xuICAgIGQoYEV4Y2VwdGlvbiB3aGlsZSBjaGVja2luZyB2ZXJzaW9uOiAke2V9YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlBhY2thZ2VNYW5hZ2VySXNudEFLbm93bkdvb2RWZXJzaW9uKFxuICBwYWNrYWdlTWFuYWdlcjogc3RyaW5nLFxuICB2ZXJzaW9uOiBzdHJpbmcsXG4gIHdoaXRlbGlzdGVkVmVyc2lvbnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gIG9yYTogT3JhSW1wbCxcbikge1xuICBjb25zdCBvc1ZlcnNpb25zID0gd2hpdGVsaXN0ZWRWZXJzaW9uc1twcm9jZXNzLnBsYXRmb3JtXTtcbiAgY29uc3QgdmVyc2lvbnMgPSBvc1ZlcnNpb25zID8gYCR7d2hpdGVsaXN0ZWRWZXJzaW9ucy5hbGx9IHx8ICR7b3NWZXJzaW9uc31gIDogd2hpdGVsaXN0ZWRWZXJzaW9ucy5hbGw7XG4gIGNvbnN0IHZlcnNpb25TdHJpbmcgPSB2ZXJzaW9uLnRvU3RyaW5nKCk7XG4gIGlmICghdmFsaWRQYWNrYWdlTWFuYWdlclZlcnNpb24ocGFja2FnZU1hbmFnZXIsIHZlcnNpb25TdHJpbmcsIHZlcnNpb25zLCBvcmEpKSB7XG4gICAgb3JhLndhcm4hKGBZb3UgYXJlIHVzaW5nICR7cGFja2FnZU1hbmFnZXJ9LCBidXQgbm90IGEga25vd24gZ29vZCB2ZXJzaW9uLlxuVGhlIGtub3duIHZlcnNpb25zIHRoYXQgd29yayB3aXRoIEVsZWN0cm9uIEZvcmdlIGFyZTogJHt2ZXJzaW9uc31gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja1BhY2thZ2VNYW5hZ2VyVmVyc2lvbihvcmE6IE9yYUltcGwpIHtcbiAgcmV0dXJuIGZvcmdlVXRpbHMueWFybk9yTnBtU3Bhd24oWyctLXZlcnNpb24nXSlcbiAgICAudGhlbigodmVyc2lvbikgPT4ge1xuICAgICAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKTtcbiAgICAgIGlmIChmb3JnZVV0aWxzLmhhc1lhcm4oKSkge1xuICAgICAgICB3YXJuSWZQYWNrYWdlTWFuYWdlcklzbnRBS25vd25Hb29kVmVyc2lvbignWWFybicsIHZlcnNpb25TdHJpbmcsIFlBUk5fV0hJVEVMSVNURURfVkVSU0lPTlMsIG9yYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuSWZQYWNrYWdlTWFuYWdlcklzbnRBS25vd25Hb29kVmVyc2lvbignTlBNJywgdmVyc2lvblN0cmluZywgTlBNX1dISVRFTElTVEVEX1ZFUlNJT05TLCBvcmEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTb21lIHBlb3BsZSBrbm93IHRoZWlyIHN5c3RlbSBpcyBPSyBhbmQgZG9uJ3QgYXBwcmVjaWF0ZSB0aGUgODAwbXMgbGFnIGluXG4gKiBzdGFydCB1cCB0aGF0IHRoZXNlIGNoZWNrcyAoaW4gcGFydGljdWxhciB0aGUgcGFja2FnZSBtYW5hZ2VyIGNoZWNrKSBjb3N0cy5cbiAqXG4gKiBTaW1wbHkgY3JlYXRpbmcgdGhpcyBmbGFnIGZpbGUgaW4geW91ciBob21lIGRpcmVjdG9yeSB3aWxsIHNraXAgdGhlc2UgY2hlY2tzXG4gKiBhbmQgc2hhdmUgfjgwMG1zIG9mZiB5b3VyIGZvcmdlIHN0YXJ0IHRpbWUuXG4gKlxuICogVGhpcyBpcyBzcGVjaWZpY2FsbHkgbm90IGRvY3VtZW50ZWQgb3IgZXZlcnlvbmUgd291bGQgbWFrZSBpdC5cbiAqL1xuY29uc3QgU0tJUF9TWVNURU1fQ0hFQ0sgPSBwYXRoLnJlc29sdmUob3MuaG9tZWRpcigpLCAnLnNraXAtZm9yZ2Utc3lzdGVtLWNoZWNrJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrU3lzdGVtKG9yYTogT3JhSW1wbCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBpZiAoIWF3YWl0IGZzLnBhdGhFeGlzdHMoU0tJUF9TWVNURU1fQ0hFQ0spKSB7XG4gICAgZCgnY2hlY2tpbmcgc3lzdGVtLCBjcmVhdGUgfi8uc2tpcC1mb3JnZS1zeXN0ZW0tY2hlY2sgdG8gc3RvcCBkb2luZyB0aGlzJyk7XG4gICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBjaGVja0dpdEV4aXN0cygpLFxuICAgICAgY2hlY2tOb2RlVmVyc2lvbigpLFxuICAgICAgY2hlY2tQYWNrYWdlTWFuYWdlclZlcnNpb24ob3JhKSxcbiAgICBdKSkuZXZlcnkoKGNoZWNrKSA9PiBjaGVjayk7XG4gIH1cbiAgZCgnc2tpcHBpbmcgc3lzdGVtIGNoZWNrJyk7XG4gIHJldHVybiB0cnVlO1xufVxuIl19