"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OraImpl = void 0;

require("source-map-support/register");

var _chalk = _interopRequireDefault(require("chalk"));

var _ora = _interopRequireDefault(require("./ora"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint "no-console": "off" */
class OraImpl {
  // eslint-disable-next-line no-empty-function, no-useless-constructor
  constructor(text = '') {
    this.text = text;
  }

  succeed(_symbol) {
    return this;
  }

  fail(_symbol) {
    return this;
  }

  start() {
    return this;
  }

  stop(_symbol) {
    return this;
  }

  warn(_message) {
    return this;
  }

}

exports.OraImpl = OraImpl;

const asyncOra = (initialOraValue, asyncFn, processExitFn = process.exit) => {
  let fnOra = new OraImpl(initialOraValue);

  if (asyncOra.interactive) {
    fnOra = (0, _ora.default)(initialOraValue).start();
  }

  return new Promise((resolve, reject) => {
    asyncFn(fnOra).then(() => {
      fnOra.succeed();
      return resolve();
    }).catch(err => {
      fnOra.fail();

      if (asyncOra.interactive) {
        if (err && err.message && err.stack) {
          console.error(_chalk.default.red('\nAn unhandled error has occurred inside Forge:'));
          console.error(_chalk.default.red(err.message));
          console.error(_chalk.default.red(err.stack));
        } else {
          console.error(_chalk.default.red('\nElectron Forge was terminated:'));
          console.error(_chalk.default.red(typeof err === 'string' ? err : JSON.stringify(err)));
        }

        processExitFn(1); // If the process is still alive we should continue because either
        // something went really wrong or we are testing this function

        setTimeout(() => resolve(), 500);
      } else {
        reject(err);
      }
    });
  });
};

asyncOra.interactive = true;
var _default = asyncOra;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9vcmEtaGFuZGxlci50cyJdLCJuYW1lcyI6WyJPcmFJbXBsIiwiY29uc3RydWN0b3IiLCJ0ZXh0Iiwic3VjY2VlZCIsIl9zeW1ib2wiLCJmYWlsIiwic3RhcnQiLCJzdG9wIiwid2FybiIsIl9tZXNzYWdlIiwiYXN5bmNPcmEiLCJpbml0aWFsT3JhVmFsdWUiLCJhc3luY0ZuIiwicHJvY2Vzc0V4aXRGbiIsInByb2Nlc3MiLCJleGl0IiwiZm5PcmEiLCJpbnRlcmFjdGl2ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsImNhdGNoIiwiZXJyIiwibWVzc2FnZSIsInN0YWNrIiwiY29uc29sZSIsImVycm9yIiwiY2hhbGsiLCJyZWQiLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0VGltZW91dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7Ozs7QUFGQTtBQUlPLE1BQU1BLE9BQU4sQ0FBYztBQUNuQjtBQUNBQyxFQUFBQSxXQUFXLENBQVFDLElBQVksR0FBRyxFQUF2QixFQUEyQjtBQUFBLFNBQW5CQSxJQUFtQixHQUFuQkEsSUFBbUI7QUFBRTs7QUFFeENDLEVBQUFBLE9BQU8sQ0FBQ0MsT0FBRCxFQUE0QjtBQUNqQyxXQUFPLElBQVA7QUFDRDs7QUFFREMsRUFBQUEsSUFBSSxDQUFDRCxPQUFELEVBQTRCO0FBQzlCLFdBQU8sSUFBUDtBQUNEOztBQUVERSxFQUFBQSxLQUFLLEdBQVk7QUFDZixXQUFPLElBQVA7QUFDRDs7QUFFREMsRUFBQUEsSUFBSSxDQUFDSCxPQUFELEVBQTRCO0FBQzlCLFdBQU8sSUFBUDtBQUNEOztBQUVESSxFQUFBQSxJQUFJLENBQUNDLFFBQUQsRUFBNEI7QUFDOUIsV0FBTyxJQUFQO0FBQ0Q7O0FBdEJrQjs7OztBQThCckIsTUFBTUMsUUFBd0IsR0FBRyxDQUFDQyxlQUFELEVBQWtCQyxPQUFsQixFQUEyQkMsYUFBYSxHQUFHQyxPQUFPLENBQUNDLElBQW5ELEtBQTREO0FBQzNGLE1BQUlDLEtBQUssR0FBRyxJQUFJaEIsT0FBSixDQUFZVyxlQUFaLENBQVo7O0FBQ0EsTUFBSUQsUUFBUSxDQUFDTyxXQUFiLEVBQTBCO0FBQ3hCRCxJQUFBQSxLQUFLLEdBQUcsa0JBQUlMLGVBQUosRUFBcUJMLEtBQXJCLEVBQVI7QUFDRDs7QUFDRCxTQUFPLElBQUlZLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENSLElBQUFBLE9BQU8sQ0FBQ0ksS0FBRCxDQUFQLENBQ0dLLElBREgsQ0FDUSxNQUFNO0FBQ1ZMLE1BQUFBLEtBQUssQ0FBQ2IsT0FBTjtBQUNBLGFBQU9nQixPQUFPLEVBQWQ7QUFDRCxLQUpILEVBS0dHLEtBTEgsQ0FLVUMsR0FBRCxJQUFTO0FBQ2RQLE1BQUFBLEtBQUssQ0FBQ1gsSUFBTjs7QUFDQSxVQUFJSyxRQUFRLENBQUNPLFdBQWIsRUFBMEI7QUFDeEIsWUFBSU0sR0FBRyxJQUFJQSxHQUFHLENBQUNDLE9BQVgsSUFBc0JELEdBQUcsQ0FBQ0UsS0FBOUIsRUFBcUM7QUFDbkNDLFVBQUFBLE9BQU8sQ0FBQ0MsS0FBUixDQUFjQyxlQUFNQyxHQUFOLENBQVUsaURBQVYsQ0FBZDtBQUNBSCxVQUFBQSxPQUFPLENBQUNDLEtBQVIsQ0FBY0MsZUFBTUMsR0FBTixDQUFVTixHQUFHLENBQUNDLE9BQWQsQ0FBZDtBQUNBRSxVQUFBQSxPQUFPLENBQUNDLEtBQVIsQ0FBY0MsZUFBTUMsR0FBTixDQUFVTixHQUFHLENBQUNFLEtBQWQsQ0FBZDtBQUNELFNBSkQsTUFJTztBQUNMQyxVQUFBQSxPQUFPLENBQUNDLEtBQVIsQ0FBY0MsZUFBTUMsR0FBTixDQUFVLGtDQUFWLENBQWQ7QUFDQUgsVUFBQUEsT0FBTyxDQUFDQyxLQUFSLENBQWNDLGVBQU1DLEdBQU4sQ0FBVSxPQUFPTixHQUFQLEtBQWUsUUFBZixHQUEwQkEsR0FBMUIsR0FBZ0NPLElBQUksQ0FBQ0MsU0FBTCxDQUFlUixHQUFmLENBQTFDLENBQWQ7QUFDRDs7QUFDRFYsUUFBQUEsYUFBYSxDQUFDLENBQUQsQ0FBYixDQVR3QixDQVV4QjtBQUNBOztBQUNBbUIsUUFBQUEsVUFBVSxDQUFDLE1BQU1iLE9BQU8sRUFBZCxFQUFrQixHQUFsQixDQUFWO0FBQ0QsT0FiRCxNQWFPO0FBQ0xDLFFBQUFBLE1BQU0sQ0FBQ0csR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQXZCSDtBQXdCRCxHQXpCTSxDQUFQO0FBMEJELENBL0JEOztBQWlDQWIsUUFBUSxDQUFDTyxXQUFULEdBQXVCLElBQXZCO2VBRWVQLFEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgXCJuby1jb25zb2xlXCI6IFwib2ZmXCIgKi9cbmltcG9ydCBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgb3JhIGZyb20gJy4vb3JhJztcblxuZXhwb3J0IGNsYXNzIE9yYUltcGwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHktZnVuY3Rpb24sIG5vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgY29uc3RydWN0b3IocHVibGljIHRleHQ6IHN0cmluZyA9ICcnKSB7fVxuXG4gIHN1Y2NlZWQoX3N5bWJvbD86IHN0cmluZyk6IE9yYUltcGwge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZmFpbChfc3ltYm9sPzogc3RyaW5nKTogT3JhSW1wbCB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGFydCgpOiBPcmFJbXBsIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoX3N5bWJvbD86IHN0cmluZyk6IE9yYUltcGwge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgd2FybihfbWVzc2FnZTogc3RyaW5nKTogT3JhSW1wbCB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3luY09yYU1ldGhvZCB7XG4gIChpbml0aWFsT3JhVmFsdWU6IHN0cmluZywgYXN5bmNGbjogKG9yYUltcGw6IE9yYUltcGwpID0+IFByb21pc2U8dm9pZD4sIHByb2Nlc3NFeGl0Rm4/OiAoY29kZTogbnVtYmVyKSA9PiB2b2lkKTogUHJvbWlzZTx2b2lkPjtcbiAgaW50ZXJhY3RpdmU/OiBib29sZWFuO1xufVxuXG5jb25zdCBhc3luY09yYTogQXN5bmNPcmFNZXRob2QgPSAoaW5pdGlhbE9yYVZhbHVlLCBhc3luY0ZuLCBwcm9jZXNzRXhpdEZuID0gcHJvY2Vzcy5leGl0KSA9PiB7XG4gIGxldCBmbk9yYSA9IG5ldyBPcmFJbXBsKGluaXRpYWxPcmFWYWx1ZSk7XG4gIGlmIChhc3luY09yYS5pbnRlcmFjdGl2ZSkge1xuICAgIGZuT3JhID0gb3JhKGluaXRpYWxPcmFWYWx1ZSkuc3RhcnQoKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFzeW5jRm4oZm5PcmEpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGZuT3JhLnN1Y2NlZWQoKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBmbk9yYS5mYWlsKCk7XG4gICAgICAgIGlmIChhc3luY09yYS5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgJiYgZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGNoYWxrLnJlZCgnXFxuQW4gdW5oYW5kbGVkIGVycm9yIGhhcyBvY2N1cnJlZCBpbnNpZGUgRm9yZ2U6JykpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihjaGFsay5yZWQoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY2hhbGsucmVkKGVyci5zdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGNoYWxrLnJlZCgnXFxuRWxlY3Ryb24gRm9yZ2Ugd2FzIHRlcm1pbmF0ZWQ6JykpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihjaGFsay5yZWQodHlwZW9mIGVyciA9PT0gJ3N0cmluZycgPyBlcnIgOiBKU09OLnN0cmluZ2lmeShlcnIpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NFeGl0Rm4oMSk7XG4gICAgICAgICAgLy8gSWYgdGhlIHByb2Nlc3MgaXMgc3RpbGwgYWxpdmUgd2Ugc2hvdWxkIGNvbnRpbnVlIGJlY2F1c2UgZWl0aGVyXG4gICAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgcmVhbGx5IHdyb25nIG9yIHdlIGFyZSB0ZXN0aW5nIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgNTAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pO1xufTtcblxuYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSB0cnVlO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luY09yYTtcbiJdfQ==