"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _readPackageJson = require("./read-package-json");

var _electronVersion = require("./electron-version");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:project-resolver'); // FIXME: If we want getElectronVersion to be overridable by plugins
//        and / or forge config then we need to be able to resolve
//        the dir without calling getElectronVersion

var _default = async dir => {
  let mDir = dir;
  let bestGuessDir = null;
  let lastError = null;
  let prevDir;

  while (prevDir !== mDir) {
    prevDir = mDir;

    const testPath = _path.default.resolve(mDir, 'package.json');

    d('searching for project in:', mDir);

    if (await _fsExtra.default.pathExists(testPath)) {
      const packageJSON = await (0, _readPackageJson.readRawPackageJson)(mDir); // TODO: Move this check to inside the forge config resolver and use
      //       mutatedPackageJson reader

      try {
        await (0, _electronVersion.getElectronVersion)(mDir, packageJSON);
      } catch (err) {
        if (err instanceof Error) {
          lastError = err.message;
        }
      }

      if (packageJSON.config && packageJSON.config.forge) {
        d('electron-forge compatible package.json found in', testPath);
        return mDir;
      }

      bestGuessDir = mDir;
    }

    mDir = _path.default.dirname(mDir);
  }

  if (bestGuessDir) {
    d('guessing on the best electron-forge package.json found in', bestGuessDir);
    return bestGuessDir;
  }

  if (lastError) {
    throw lastError;
  }

  return null;
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3Jlc29sdmUtZGlyLnRzIl0sIm5hbWVzIjpbImQiLCJkaXIiLCJtRGlyIiwiYmVzdEd1ZXNzRGlyIiwibGFzdEVycm9yIiwicHJldkRpciIsInRlc3RQYXRoIiwicGF0aCIsInJlc29sdmUiLCJmcyIsInBhdGhFeGlzdHMiLCJwYWNrYWdlSlNPTiIsImVyciIsIkVycm9yIiwibWVzc2FnZSIsImNvbmZpZyIsImZvcmdlIiwiZGlybmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxDQUFDLEdBQUcsb0JBQU0saUNBQU4sQ0FBVixDLENBRUE7QUFDQTtBQUNBOztlQUNlLE1BQU9DLEdBQVAsSUFBK0M7QUFDNUQsTUFBSUMsSUFBSSxHQUFHRCxHQUFYO0FBQ0EsTUFBSUUsWUFBMkIsR0FBRyxJQUFsQztBQUNBLE1BQUlDLFNBQXdCLEdBQUcsSUFBL0I7QUFFQSxNQUFJQyxPQUFKOztBQUNBLFNBQU9BLE9BQU8sS0FBS0gsSUFBbkIsRUFBeUI7QUFDdkJHLElBQUFBLE9BQU8sR0FBR0gsSUFBVjs7QUFDQSxVQUFNSSxRQUFRLEdBQUdDLGNBQUtDLE9BQUwsQ0FBYU4sSUFBYixFQUFtQixjQUFuQixDQUFqQjs7QUFDQUYsSUFBQUEsQ0FBQyxDQUFDLDJCQUFELEVBQThCRSxJQUE5QixDQUFEOztBQUNBLFFBQUksTUFBTU8saUJBQUdDLFVBQUgsQ0FBY0osUUFBZCxDQUFWLEVBQW1DO0FBQ2pDLFlBQU1LLFdBQVcsR0FBRyxNQUFNLHlDQUFtQlQsSUFBbkIsQ0FBMUIsQ0FEaUMsQ0FHakM7QUFDQTs7QUFDQSxVQUFJO0FBQ0YsY0FBTSx5Q0FBbUJBLElBQW5CLEVBQXlCUyxXQUF6QixDQUFOO0FBQ0QsT0FGRCxDQUVFLE9BQU9DLEdBQVAsRUFBWTtBQUNaLFlBQUlBLEdBQUcsWUFBWUMsS0FBbkIsRUFBMEI7QUFDeEJULFVBQUFBLFNBQVMsR0FBR1EsR0FBRyxDQUFDRSxPQUFoQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSUgsV0FBVyxDQUFDSSxNQUFaLElBQXNCSixXQUFXLENBQUNJLE1BQVosQ0FBbUJDLEtBQTdDLEVBQW9EO0FBQ2xEaEIsUUFBQUEsQ0FBQyxDQUFDLGlEQUFELEVBQW9ETSxRQUFwRCxDQUFEO0FBQ0EsZUFBT0osSUFBUDtBQUNEOztBQUVEQyxNQUFBQSxZQUFZLEdBQUdELElBQWY7QUFDRDs7QUFDREEsSUFBQUEsSUFBSSxHQUFHSyxjQUFLVSxPQUFMLENBQWFmLElBQWIsQ0FBUDtBQUNEOztBQUNELE1BQUlDLFlBQUosRUFBa0I7QUFDaEJILElBQUFBLENBQUMsQ0FBQywyREFBRCxFQUE4REcsWUFBOUQsQ0FBRDtBQUNBLFdBQU9BLFlBQVA7QUFDRDs7QUFDRCxNQUFJQyxTQUFKLEVBQWU7QUFDYixVQUFNQSxTQUFOO0FBQ0Q7O0FBQ0QsU0FBTyxJQUFQO0FBQ0QsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyByZWFkUmF3UGFja2FnZUpzb24gfSBmcm9tICcuL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCB7IGdldEVsZWN0cm9uVmVyc2lvbiB9IGZyb20gJy4vZWxlY3Ryb24tdmVyc2lvbic7XG5cbmNvbnN0IGQgPSBkZWJ1ZygnZWxlY3Ryb24tZm9yZ2U6cHJvamVjdC1yZXNvbHZlcicpO1xuXG4vLyBGSVhNRTogSWYgd2Ugd2FudCBnZXRFbGVjdHJvblZlcnNpb24gdG8gYmUgb3ZlcnJpZGFibGUgYnkgcGx1Z2luc1xuLy8gICAgICAgIGFuZCAvIG9yIGZvcmdlIGNvbmZpZyB0aGVuIHdlIG5lZWQgdG8gYmUgYWJsZSB0byByZXNvbHZlXG4vLyAgICAgICAgdGhlIGRpciB3aXRob3V0IGNhbGxpbmcgZ2V0RWxlY3Ryb25WZXJzaW9uXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+ID0+IHtcbiAgbGV0IG1EaXIgPSBkaXI7XG4gIGxldCBiZXN0R3Vlc3NEaXI6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBsZXQgbGFzdEVycm9yOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICBsZXQgcHJldkRpcjtcbiAgd2hpbGUgKHByZXZEaXIgIT09IG1EaXIpIHtcbiAgICBwcmV2RGlyID0gbURpcjtcbiAgICBjb25zdCB0ZXN0UGF0aCA9IHBhdGgucmVzb2x2ZShtRGlyLCAncGFja2FnZS5qc29uJyk7XG4gICAgZCgnc2VhcmNoaW5nIGZvciBwcm9qZWN0IGluOicsIG1EaXIpO1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKHRlc3RQYXRoKSkge1xuICAgICAgY29uc3QgcGFja2FnZUpTT04gPSBhd2FpdCByZWFkUmF3UGFja2FnZUpzb24obURpcik7XG5cbiAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBjaGVjayB0byBpbnNpZGUgdGhlIGZvcmdlIGNvbmZpZyByZXNvbHZlciBhbmQgdXNlXG4gICAgICAvLyAgICAgICBtdXRhdGVkUGFja2FnZUpzb24gcmVhZGVyXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBnZXRFbGVjdHJvblZlcnNpb24obURpciwgcGFja2FnZUpTT04pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGxhc3RFcnJvciA9IGVyci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWNrYWdlSlNPTi5jb25maWcgJiYgcGFja2FnZUpTT04uY29uZmlnLmZvcmdlKSB7XG4gICAgICAgIGQoJ2VsZWN0cm9uLWZvcmdlIGNvbXBhdGlibGUgcGFja2FnZS5qc29uIGZvdW5kIGluJywgdGVzdFBhdGgpO1xuICAgICAgICByZXR1cm4gbURpcjtcbiAgICAgIH1cblxuICAgICAgYmVzdEd1ZXNzRGlyID0gbURpcjtcbiAgICB9XG4gICAgbURpciA9IHBhdGguZGlybmFtZShtRGlyKTtcbiAgfVxuICBpZiAoYmVzdEd1ZXNzRGlyKSB7XG4gICAgZCgnZ3Vlc3Npbmcgb24gdGhlIGJlc3QgZWxlY3Ryb24tZm9yZ2UgcGFja2FnZS5qc29uIGZvdW5kIGluJywgYmVzdEd1ZXNzRGlyKTtcbiAgICByZXR1cm4gYmVzdEd1ZXNzRGlyO1xuICB9XG4gIGlmIChsYXN0RXJyb3IpIHtcbiAgICB0aHJvdyBsYXN0RXJyb3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuIl19