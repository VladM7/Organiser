"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElectronModulePath = getElectronModulePath;
exports.getElectronVersion = getElectronVersion;
exports.updateElectronDependency = updateElectronDependency;
exports.PackageNotFoundError = void 0;

require("source-map-support/register");

var _debug = _interopRequireDefault(require("debug"));

var _findUp = _interopRequireDefault(require("find-up"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _yarnOrNpm = _interopRequireWildcard(require("./yarn-or-npm"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:electron-version');
const electronPackageNames = ['electron-prebuilt-compile', 'electron-prebuilt', 'electron-nightly', 'electron'];

function findElectronDep(dep) {
  return electronPackageNames.includes(dep);
}

async function findAncestorNodeModulesPath(dir) {
  if ((0, _yarnOrNpm.hasYarn)()) {
    const yarnLockPath = await (0, _findUp.default)('yarn.lock', {
      cwd: dir,
      type: 'file'
    });

    if (yarnLockPath) {
      const nodeModulesPath = _path.default.join(_path.default.dirname(yarnLockPath), 'node_modules');

      if (await _fsExtra.default.pathExists(nodeModulesPath)) {
        return nodeModulesPath;
      }
    }
  }

  return Promise.resolve(undefined);
}

async function determineNodeModulesPath(dir) {
  const nodeModulesPath = _path.default.join(dir, 'node_modules');

  if (await _fsExtra.default.pathExists(nodeModulesPath)) {
    return nodeModulesPath;
  }

  return findAncestorNodeModulesPath(dir);
}

class PackageNotFoundError extends Error {
  constructor(packageName, dir) {
    super(`Cannot find the package "${packageName}". Perhaps you need to run "${(0, _yarnOrNpm.default)()} install" in "${dir}"?`);
  }

}

exports.PackageNotFoundError = PackageNotFoundError;

function getElectronModuleName(packageJSON) {
  if (!packageJSON.devDependencies) {
    throw new Error('package.json for app does not have any devDependencies'.red);
  }

  const packageName = electronPackageNames.find(pkg => packageJSON.devDependencies[pkg]);

  if (packageName === undefined) {
    throw new Error('Could not find any Electron packages in devDependencies');
  }

  return packageName;
}

async function getElectronPackageJSONPath(dir, packageName) {
  const nodeModulesPath = await determineNodeModulesPath(dir);

  if (!nodeModulesPath) {
    throw new PackageNotFoundError(packageName, dir);
  }

  const electronPackageJSONPath = _path.default.join(nodeModulesPath, packageName, 'package.json');

  if (await _fsExtra.default.pathExists(electronPackageJSONPath)) {
    return electronPackageJSONPath;
  }

  return undefined;
}

async function getElectronModulePath(dir, packageJSON) {
  const moduleName = await getElectronModuleName(packageJSON);
  const packageJSONPath = await getElectronPackageJSONPath(dir, moduleName);

  if (packageJSONPath) {
    return _path.default.dirname(packageJSONPath);
  }

  return undefined;
}

async function getElectronVersion(dir, packageJSON) {
  const packageName = getElectronModuleName(packageJSON);
  let version = packageJSON.devDependencies[packageName];

  if (!_semver.default.valid(version)) {
    // It's not an exact version, find it in the actual module
    const electronPackageJSONPath = await getElectronPackageJSONPath(dir, packageName);

    if (electronPackageJSONPath) {
      const electronPackageJSON = await _fsExtra.default.readJson(electronPackageJSONPath); // eslint-disable-next-line prefer-destructuring

      version = electronPackageJSON.version;
    } else {
      throw new PackageNotFoundError(packageName, dir);
    }
  }

  return version;
}

function updateElectronDependency(packageJSON, dev, exact) {
  const alteredDev = [].concat(dev);
  let alteredExact = [].concat(exact);

  if (Object.keys(packageJSON.devDependencies).find(findElectronDep)) {
    alteredExact = alteredExact.filter(dep => dep !== 'electron');
  } else {
    const electronKey = Object.keys(packageJSON.dependencies).find(findElectronDep);

    if (electronKey) {
      alteredExact = alteredExact.filter(dep => dep !== 'electron');
      d(`Moving ${electronKey} from dependencies to devDependencies`);
      alteredDev.push(`${electronKey}@${packageJSON.dependencies[electronKey]}`);
      delete packageJSON.dependencies[electronKey];
    }
  }

  return [alteredDev, alteredExact];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2VsZWN0cm9uLXZlcnNpb24udHMiXSwibmFtZXMiOlsiZCIsImVsZWN0cm9uUGFja2FnZU5hbWVzIiwiZmluZEVsZWN0cm9uRGVwIiwiZGVwIiwiaW5jbHVkZXMiLCJmaW5kQW5jZXN0b3JOb2RlTW9kdWxlc1BhdGgiLCJkaXIiLCJ5YXJuTG9ja1BhdGgiLCJjd2QiLCJ0eXBlIiwibm9kZU1vZHVsZXNQYXRoIiwicGF0aCIsImpvaW4iLCJkaXJuYW1lIiwiZnMiLCJwYXRoRXhpc3RzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1bmRlZmluZWQiLCJkZXRlcm1pbmVOb2RlTW9kdWxlc1BhdGgiLCJQYWNrYWdlTm90Rm91bmRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJwYWNrYWdlTmFtZSIsImdldEVsZWN0cm9uTW9kdWxlTmFtZSIsInBhY2thZ2VKU09OIiwiZGV2RGVwZW5kZW5jaWVzIiwicmVkIiwiZmluZCIsInBrZyIsImdldEVsZWN0cm9uUGFja2FnZUpTT05QYXRoIiwiZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGgiLCJnZXRFbGVjdHJvbk1vZHVsZVBhdGgiLCJtb2R1bGVOYW1lIiwicGFja2FnZUpTT05QYXRoIiwiZ2V0RWxlY3Ryb25WZXJzaW9uIiwidmVyc2lvbiIsInNlbXZlciIsInZhbGlkIiwiZWxlY3Ryb25QYWNrYWdlSlNPTiIsInJlYWRKc29uIiwidXBkYXRlRWxlY3Ryb25EZXBlbmRlbmN5IiwiZGV2IiwiZXhhY3QiLCJhbHRlcmVkRGV2IiwiY29uY2F0IiwiYWx0ZXJlZEV4YWN0IiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImVsZWN0cm9uS2V5IiwiZGVwZW5kZW5jaWVzIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHLG9CQUFNLGlDQUFOLENBQVY7QUFFQSxNQUFNQyxvQkFBb0IsR0FBRyxDQUMzQiwyQkFEMkIsRUFFM0IsbUJBRjJCLEVBRzNCLGtCQUgyQixFQUkzQixVQUoyQixDQUE3Qjs7QUFPQSxTQUFTQyxlQUFULENBQXlCQyxHQUF6QixFQUErQztBQUM3QyxTQUFPRixvQkFBb0IsQ0FBQ0csUUFBckIsQ0FBOEJELEdBQTlCLENBQVA7QUFDRDs7QUFFRCxlQUFlRSwyQkFBZixDQUEyQ0MsR0FBM0MsRUFBcUY7QUFDbkYsTUFBSSx5QkFBSixFQUFlO0FBQ2IsVUFBTUMsWUFBWSxHQUFHLE1BQU0scUJBQU8sV0FBUCxFQUFvQjtBQUFFQyxNQUFBQSxHQUFHLEVBQUVGLEdBQVA7QUFBWUcsTUFBQUEsSUFBSSxFQUFFO0FBQWxCLEtBQXBCLENBQTNCOztBQUNBLFFBQUlGLFlBQUosRUFBa0I7QUFDaEIsWUFBTUcsZUFBZSxHQUFHQyxjQUFLQyxJQUFMLENBQVVELGNBQUtFLE9BQUwsQ0FBYU4sWUFBYixDQUFWLEVBQXNDLGNBQXRDLENBQXhCOztBQUNBLFVBQUksTUFBTU8saUJBQUdDLFVBQUgsQ0FBY0wsZUFBZCxDQUFWLEVBQTBDO0FBQ3hDLGVBQU9BLGVBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBT00sT0FBTyxDQUFDQyxPQUFSLENBQWdCQyxTQUFoQixDQUFQO0FBQ0Q7O0FBRUQsZUFBZUMsd0JBQWYsQ0FBd0NiLEdBQXhDLEVBQWtGO0FBQ2hGLFFBQU1JLGVBQW1DLEdBQUdDLGNBQUtDLElBQUwsQ0FBVU4sR0FBVixFQUFlLGNBQWYsQ0FBNUM7O0FBQ0EsTUFBSSxNQUFNUSxpQkFBR0MsVUFBSCxDQUFjTCxlQUFkLENBQVYsRUFBMEM7QUFDeEMsV0FBT0EsZUFBUDtBQUNEOztBQUNELFNBQU9MLDJCQUEyQixDQUFDQyxHQUFELENBQWxDO0FBQ0Q7O0FBRU0sTUFBTWMsb0JBQU4sU0FBbUNDLEtBQW5DLENBQXlDO0FBQzlDQyxFQUFBQSxXQUFXLENBQUNDLFdBQUQsRUFBc0JqQixHQUF0QixFQUFtQztBQUM1QyxVQUFPLDRCQUEyQmlCLFdBQVksK0JBQThCLHlCQUFZLGlCQUFnQmpCLEdBQUksSUFBNUc7QUFDRDs7QUFINkM7Ozs7QUFNaEQsU0FBU2tCLHFCQUFULENBQStCQyxXQUEvQixFQUF5RDtBQUN2RCxNQUFJLENBQUNBLFdBQVcsQ0FBQ0MsZUFBakIsRUFBa0M7QUFDaEMsVUFBTSxJQUFJTCxLQUFKLENBQVUseURBQXlETSxHQUFuRSxDQUFOO0FBQ0Q7O0FBRUQsUUFBTUosV0FBVyxHQUFHdEIsb0JBQW9CLENBQUMyQixJQUFyQixDQUEyQkMsR0FBRCxJQUFTSixXQUFXLENBQUNDLGVBQVosQ0FBNEJHLEdBQTVCLENBQW5DLENBQXBCOztBQUNBLE1BQUlOLFdBQVcsS0FBS0wsU0FBcEIsRUFBK0I7QUFDN0IsVUFBTSxJQUFJRyxLQUFKLENBQVUseURBQVYsQ0FBTjtBQUNEOztBQUVELFNBQU9FLFdBQVA7QUFDRDs7QUFFRCxlQUFlTywwQkFBZixDQUNFeEIsR0FERixFQUVFaUIsV0FGRixFQUcrQjtBQUM3QixRQUFNYixlQUFlLEdBQUcsTUFBTVMsd0JBQXdCLENBQUNiLEdBQUQsQ0FBdEQ7O0FBQ0EsTUFBSSxDQUFDSSxlQUFMLEVBQXNCO0FBQ3BCLFVBQU0sSUFBSVUsb0JBQUosQ0FBeUJHLFdBQXpCLEVBQXNDakIsR0FBdEMsQ0FBTjtBQUNEOztBQUNELFFBQU15Qix1QkFBdUIsR0FBR3BCLGNBQUtDLElBQUwsQ0FBVUYsZUFBVixFQUEyQmEsV0FBM0IsRUFBd0MsY0FBeEMsQ0FBaEM7O0FBQ0EsTUFBSSxNQUFNVCxpQkFBR0MsVUFBSCxDQUFjZ0IsdUJBQWQsQ0FBVixFQUFrRDtBQUNoRCxXQUFPQSx1QkFBUDtBQUNEOztBQUVELFNBQU9iLFNBQVA7QUFDRDs7QUFFTSxlQUFlYyxxQkFBZixDQUNMMUIsR0FESyxFQUVMbUIsV0FGSyxFQUd3QjtBQUM3QixRQUFNUSxVQUFVLEdBQUcsTUFBTVQscUJBQXFCLENBQUNDLFdBQUQsQ0FBOUM7QUFDQSxRQUFNUyxlQUFlLEdBQUcsTUFBTUosMEJBQTBCLENBQUN4QixHQUFELEVBQU0yQixVQUFOLENBQXhEOztBQUNBLE1BQUlDLGVBQUosRUFBcUI7QUFDbkIsV0FBT3ZCLGNBQUtFLE9BQUwsQ0FBYXFCLGVBQWIsQ0FBUDtBQUNEOztBQUVELFNBQU9oQixTQUFQO0FBQ0Q7O0FBRU0sZUFBZWlCLGtCQUFmLENBQWtDN0IsR0FBbEMsRUFBK0NtQixXQUEvQyxFQUFrRjtBQUN2RixRQUFNRixXQUFXLEdBQUdDLHFCQUFxQixDQUFDQyxXQUFELENBQXpDO0FBRUEsTUFBSVcsT0FBTyxHQUFHWCxXQUFXLENBQUNDLGVBQVosQ0FBNEJILFdBQTVCLENBQWQ7O0FBQ0EsTUFBSSxDQUFDYyxnQkFBT0MsS0FBUCxDQUFhRixPQUFiLENBQUwsRUFBNEI7QUFBRTtBQUM1QixVQUFNTCx1QkFBdUIsR0FBRyxNQUFNRCwwQkFBMEIsQ0FBQ3hCLEdBQUQsRUFBTWlCLFdBQU4sQ0FBaEU7O0FBQ0EsUUFBSVEsdUJBQUosRUFBNkI7QUFDM0IsWUFBTVEsbUJBQW1CLEdBQUcsTUFBTXpCLGlCQUFHMEIsUUFBSCxDQUFZVCx1QkFBWixDQUFsQyxDQUQyQixDQUUzQjs7QUFDQUssTUFBQUEsT0FBTyxHQUFHRyxtQkFBbUIsQ0FBQ0gsT0FBOUI7QUFDRCxLQUpELE1BSU87QUFDTCxZQUFNLElBQUloQixvQkFBSixDQUF5QkcsV0FBekIsRUFBc0NqQixHQUF0QyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPOEIsT0FBUDtBQUNEOztBQUVNLFNBQVNLLHdCQUFULENBQ0xoQixXQURLLEVBRUxpQixHQUZLLEVBR0xDLEtBSEssRUFJaUI7QUFDdEIsUUFBTUMsVUFBVSxHQUFJLEVBQUQsQ0FBaUJDLE1BQWpCLENBQXdCSCxHQUF4QixDQUFuQjtBQUNBLE1BQUlJLFlBQVksR0FBSSxFQUFELENBQWlCRCxNQUFqQixDQUF3QkYsS0FBeEIsQ0FBbkI7O0FBQ0EsTUFBSUksTUFBTSxDQUFDQyxJQUFQLENBQVl2QixXQUFXLENBQUNDLGVBQXhCLEVBQXlDRSxJQUF6QyxDQUE4QzFCLGVBQTlDLENBQUosRUFBb0U7QUFDbEU0QyxJQUFBQSxZQUFZLEdBQUdBLFlBQVksQ0FBQ0csTUFBYixDQUFxQjlDLEdBQUQsSUFBU0EsR0FBRyxLQUFLLFVBQXJDLENBQWY7QUFDRCxHQUZELE1BRU87QUFDTCxVQUFNK0MsV0FBVyxHQUFHSCxNQUFNLENBQUNDLElBQVAsQ0FBWXZCLFdBQVcsQ0FBQzBCLFlBQXhCLEVBQXNDdkIsSUFBdEMsQ0FBMkMxQixlQUEzQyxDQUFwQjs7QUFDQSxRQUFJZ0QsV0FBSixFQUFpQjtBQUNmSixNQUFBQSxZQUFZLEdBQUdBLFlBQVksQ0FBQ0csTUFBYixDQUFxQjlDLEdBQUQsSUFBU0EsR0FBRyxLQUFLLFVBQXJDLENBQWY7QUFDQUgsTUFBQUEsQ0FBQyxDQUFFLFVBQVNrRCxXQUFZLHVDQUF2QixDQUFEO0FBQ0FOLE1BQUFBLFVBQVUsQ0FBQ1EsSUFBWCxDQUFpQixHQUFFRixXQUFZLElBQUd6QixXQUFXLENBQUMwQixZQUFaLENBQXlCRCxXQUF6QixDQUFzQyxFQUF4RTtBQUNBLGFBQU96QixXQUFXLENBQUMwQixZQUFaLENBQXlCRCxXQUF6QixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLENBQUNOLFVBQUQsRUFBYUUsWUFBYixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGZpbmRVcCBmcm9tICdmaW5kLXVwJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB5YXJuT3JOcG0sIHsgaGFzWWFybiB9IGZyb20gJy4veWFybi1vci1ucG0nO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOmVsZWN0cm9uLXZlcnNpb24nKTtcblxuY29uc3QgZWxlY3Ryb25QYWNrYWdlTmFtZXMgPSBbXG4gICdlbGVjdHJvbi1wcmVidWlsdC1jb21waWxlJyxcbiAgJ2VsZWN0cm9uLXByZWJ1aWx0JyxcbiAgJ2VsZWN0cm9uLW5pZ2h0bHknLFxuICAnZWxlY3Ryb24nLFxuXTtcblxuZnVuY3Rpb24gZmluZEVsZWN0cm9uRGVwKGRlcDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBlbGVjdHJvblBhY2thZ2VOYW1lcy5pbmNsdWRlcyhkZXApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kQW5jZXN0b3JOb2RlTW9kdWxlc1BhdGgoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBpZiAoaGFzWWFybigpKSB7XG4gICAgY29uc3QgeWFybkxvY2tQYXRoID0gYXdhaXQgZmluZFVwKCd5YXJuLmxvY2snLCB7IGN3ZDogZGlyLCB0eXBlOiAnZmlsZScgfSk7XG4gICAgaWYgKHlhcm5Mb2NrUGF0aCkge1xuICAgICAgY29uc3Qgbm9kZU1vZHVsZXNQYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZSh5YXJuTG9ja1BhdGgpLCAnbm9kZV9tb2R1bGVzJyk7XG4gICAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhub2RlTW9kdWxlc1BhdGgpKSB7XG4gICAgICAgIHJldHVybiBub2RlTW9kdWxlc1BhdGg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVOb2RlTW9kdWxlc1BhdGgoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBub2RlTW9kdWxlc1BhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHBhdGguam9pbihkaXIsICdub2RlX21vZHVsZXMnKTtcbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMobm9kZU1vZHVsZXNQYXRoKSkge1xuICAgIHJldHVybiBub2RlTW9kdWxlc1BhdGg7XG4gIH1cbiAgcmV0dXJuIGZpbmRBbmNlc3Rvck5vZGVNb2R1bGVzUGF0aChkaXIpO1xufVxuXG5leHBvcnQgY2xhc3MgUGFja2FnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhY2thZ2VOYW1lOiBzdHJpbmcsIGRpcjogc3RyaW5nKSB7XG4gICAgc3VwZXIoYENhbm5vdCBmaW5kIHRoZSBwYWNrYWdlIFwiJHtwYWNrYWdlTmFtZX1cIi4gUGVyaGFwcyB5b3UgbmVlZCB0byBydW4gXCIke3lhcm5Pck5wbSgpfSBpbnN0YWxsXCIgaW4gXCIke2Rpcn1cIj9gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVjdHJvbk1vZHVsZU5hbWUocGFja2FnZUpTT046IGFueSk6IHN0cmluZyB7XG4gIGlmICghcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrYWdlLmpzb24gZm9yIGFwcCBkb2VzIG5vdCBoYXZlIGFueSBkZXZEZXBlbmRlbmNpZXMnLnJlZCk7XG4gIH1cblxuICBjb25zdCBwYWNrYWdlTmFtZSA9IGVsZWN0cm9uUGFja2FnZU5hbWVzLmZpbmQoKHBrZykgPT4gcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzW3BrZ10pO1xuICBpZiAocGFja2FnZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYW55IEVsZWN0cm9uIHBhY2thZ2VzIGluIGRldkRlcGVuZGVuY2llcycpO1xuICB9XG5cbiAgcmV0dXJuIHBhY2thZ2VOYW1lO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRFbGVjdHJvblBhY2thZ2VKU09OUGF0aChcbiAgZGlyOiBzdHJpbmcsXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBub2RlTW9kdWxlc1BhdGggPSBhd2FpdCBkZXRlcm1pbmVOb2RlTW9kdWxlc1BhdGgoZGlyKTtcbiAgaWYgKCFub2RlTW9kdWxlc1BhdGgpIHtcbiAgICB0aHJvdyBuZXcgUGFja2FnZU5vdEZvdW5kRXJyb3IocGFja2FnZU5hbWUsIGRpcik7XG4gIH1cbiAgY29uc3QgZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGggPSBwYXRoLmpvaW4obm9kZU1vZHVsZXNQYXRoLCBwYWNrYWdlTmFtZSwgJ3BhY2thZ2UuanNvbicpO1xuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhlbGVjdHJvblBhY2thZ2VKU09OUGF0aCkpIHtcbiAgICByZXR1cm4gZWxlY3Ryb25QYWNrYWdlSlNPTlBhdGg7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RWxlY3Ryb25Nb2R1bGVQYXRoKFxuICBkaXI6IHN0cmluZyxcbiAgcGFja2FnZUpTT046IGFueSxcbik6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IG1vZHVsZU5hbWUgPSBhd2FpdCBnZXRFbGVjdHJvbk1vZHVsZU5hbWUocGFja2FnZUpTT04pO1xuICBjb25zdCBwYWNrYWdlSlNPTlBhdGggPSBhd2FpdCBnZXRFbGVjdHJvblBhY2thZ2VKU09OUGF0aChkaXIsIG1vZHVsZU5hbWUpO1xuICBpZiAocGFja2FnZUpTT05QYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguZGlybmFtZShwYWNrYWdlSlNPTlBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVsZWN0cm9uVmVyc2lvbihkaXI6IHN0cmluZywgcGFja2FnZUpTT046IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHBhY2thZ2VOYW1lID0gZ2V0RWxlY3Ryb25Nb2R1bGVOYW1lKHBhY2thZ2VKU09OKTtcblxuICBsZXQgdmVyc2lvbiA9IHBhY2thZ2VKU09OLmRldkRlcGVuZGVuY2llc1twYWNrYWdlTmFtZV07XG4gIGlmICghc2VtdmVyLnZhbGlkKHZlcnNpb24pKSB7IC8vIEl0J3Mgbm90IGFuIGV4YWN0IHZlcnNpb24sIGZpbmQgaXQgaW4gdGhlIGFjdHVhbCBtb2R1bGVcbiAgICBjb25zdCBlbGVjdHJvblBhY2thZ2VKU09OUGF0aCA9IGF3YWl0IGdldEVsZWN0cm9uUGFja2FnZUpTT05QYXRoKGRpciwgcGFja2FnZU5hbWUpO1xuICAgIGlmIChlbGVjdHJvblBhY2thZ2VKU09OUGF0aCkge1xuICAgICAgY29uc3QgZWxlY3Ryb25QYWNrYWdlSlNPTiA9IGF3YWl0IGZzLnJlYWRKc29uKGVsZWN0cm9uUGFja2FnZUpTT05QYXRoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgdmVyc2lvbiA9IGVsZWN0cm9uUGFja2FnZUpTT04udmVyc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFBhY2thZ2VOb3RGb3VuZEVycm9yKHBhY2thZ2VOYW1lLCBkaXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRWxlY3Ryb25EZXBlbmRlbmN5KFxuICBwYWNrYWdlSlNPTjogYW55LFxuICBkZXY6IHN0cmluZ1tdLFxuICBleGFjdDogc3RyaW5nW10sXG4pOiBbc3RyaW5nW10sIHN0cmluZ1tdXSB7XG4gIGNvbnN0IGFsdGVyZWREZXYgPSAoW10gYXMgc3RyaW5nW10pLmNvbmNhdChkZXYpO1xuICBsZXQgYWx0ZXJlZEV4YWN0ID0gKFtdIGFzIHN0cmluZ1tdKS5jb25jYXQoZXhhY3QpO1xuICBpZiAoT2JqZWN0LmtleXMocGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzKS5maW5kKGZpbmRFbGVjdHJvbkRlcCkpIHtcbiAgICBhbHRlcmVkRXhhY3QgPSBhbHRlcmVkRXhhY3QuZmlsdGVyKChkZXApID0+IGRlcCAhPT0gJ2VsZWN0cm9uJyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZWxlY3Ryb25LZXkgPSBPYmplY3Qua2V5cyhwYWNrYWdlSlNPTi5kZXBlbmRlbmNpZXMpLmZpbmQoZmluZEVsZWN0cm9uRGVwKTtcbiAgICBpZiAoZWxlY3Ryb25LZXkpIHtcbiAgICAgIGFsdGVyZWRFeGFjdCA9IGFsdGVyZWRFeGFjdC5maWx0ZXIoKGRlcCkgPT4gZGVwICE9PSAnZWxlY3Ryb24nKTtcbiAgICAgIGQoYE1vdmluZyAke2VsZWN0cm9uS2V5fSBmcm9tIGRlcGVuZGVuY2llcyB0byBkZXZEZXBlbmRlbmNpZXNgKTtcbiAgICAgIGFsdGVyZWREZXYucHVzaChgJHtlbGVjdHJvbktleX1AJHtwYWNrYWdlSlNPTi5kZXBlbmRlbmNpZXNbZWxlY3Ryb25LZXldfWApO1xuICAgICAgZGVsZXRlIHBhY2thZ2VKU09OLmRlcGVuZGVuY2llc1tlbGVjdHJvbktleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFthbHRlcmVkRGV2LCBhbHRlcmVkRXhhY3RdO1xufVxuIl19