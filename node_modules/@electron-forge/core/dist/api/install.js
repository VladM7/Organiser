"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _installerBase = _interopRequireDefault(require("@electron-forge/installer-base"));

var _debug = _interopRequireDefault(require("debug"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _util = require("util");

var _semver = _interopRequireDefault(require("semver"));

var _installerDmg = _interopRequireDefault(require("@electron-forge/installer-dmg"));

var _installerZip = _interopRequireDefault(require("@electron-forge/installer-zip"));

var _installerDeb = _interopRequireDefault(require("@electron-forge/installer-deb"));

var _installerRpm = _interopRequireDefault(require("@electron-forge/installer-rpm"));

var _installerExe = _interopRequireDefault(require("@electron-forge/installer-exe"));

var _messages = require("../util/messages");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const nugget = require('nugget');

const d = (0, _debug.default)('electron-forge:install');
const GITHUB_API = 'https://api.github.com';

class InstallerImpl extends _installerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'impl');
  }

}

var _default = async ({
  interactive = false,
  prerelease = false,
  repo,
  chooseAsset
}) => {
  _asyncOra.asyncOra.interactive = interactive;

  if (typeof chooseAsset !== 'function') {
    throw new Error('Expected chooseAsset to be a function in install call');
  }

  let latestRelease;
  let possibleAssets = [];
  await (0, _asyncOra.asyncOra)('Searching for Application', async searchSpinner => {
    if (!repo || !repo.includes('/')) {
      throw new Error('Invalid repository name, must be in the format owner/name');
    }

    d('searching for repo:', repo);
    let releases;

    try {
      releases = await (await (0, _nodeFetch.default)(`${GITHUB_API}/repos/${repo}/releases`)).json();
    } catch (err) {// Ignore error
    }

    if (!releases || releases.message === 'Not Found' || !Array.isArray(releases)) {
      throw new Error(`Failed to find releases for repository "${repo}".  Please check the name and try again.`);
    }

    if (releases.length === 0) {
      throw new Error(`Repository "${repo}" has no releases`);
    }

    releases = releases.filter(release => !release.prerelease || prerelease);
    const sortedReleases = releases.sort((releaseA, releaseB) => {
      let tagA = releaseA.tag_name;
      if (tagA.substr(0, 1) === 'v') tagA = tagA.substr(1);
      let tagB = releaseB.tag_name;
      if (tagB.substr(0, 1) === 'v') tagB = tagB.substr(1);
      return _semver.default.gt(tagB, tagA) ? 1 : -1;
    }); // eslint-disable-next-line prefer-destructuring

    latestRelease = sortedReleases[0];
    searchSpinner.text = 'Searching for Releases';
    const {
      assets
    } = latestRelease;

    if (!assets || !Array.isArray(assets) || assets.length === 0) {
      throw new Error('Could not find any assets for the latest release');
    }

    const installTargets = {
      win32: [/\.exe$/],
      darwin: [/OSX.*\.zip$/, /darwin.*\.zip$/, /macOS.*\.zip$/, /mac.*\.zip$/, /\.dmg$/],
      linux: [/\.rpm$/, /\.deb$/]
    };
    possibleAssets = assets.filter(asset => {
      const targetSuffixes = installTargets[process.platform];

      for (const suffix of targetSuffixes) {
        if (suffix.test(asset.name)) return true;
      }

      return false;
    });

    if (possibleAssets.length === 0) {
      throw new Error(`Failed to find any installable assets for target platform: ${`${process.platform}`.cyan}`);
    }
  });
  (0, _messages.info)(interactive, `Found latest release${prerelease ? ' (including prereleases)' : ''}: ${latestRelease.tag_name.cyan}`);
  let targetAsset = possibleAssets[0];

  if (possibleAssets.length > 1) {
    targetAsset = await Promise.resolve(chooseAsset(possibleAssets));
  }

  const tmpdir = _path.default.resolve(_os.default.tmpdir(), 'forge-install');

  const pathSafeRepo = repo.replace(/[/\\]/g, '-');
  const filename = `${pathSafeRepo}-${latestRelease.tag_name}-${targetAsset.name}`;

  const fullFilePath = _path.default.resolve(tmpdir, filename);

  if (!(await _fsExtra.default.pathExists(fullFilePath)) || (await _fsExtra.default.stat(fullFilePath)).size !== targetAsset.size) {
    await _fsExtra.default.mkdirs(tmpdir);
    const nuggetOpts = {
      target: filename,
      dir: tmpdir,
      resume: true,
      strictSSL: true
    };
    await (0, _util.promisify)(nugget)(targetAsset.browser_download_url, nuggetOpts);
  }

  await (0, _asyncOra.asyncOra)('Installing Application', async installSpinner => {
    const installActions = {
      win32: {
        '.exe': _installerExe.default
      },
      darwin: {
        '.zip': _installerZip.default,
        '.dmg': _installerDmg.default
      },
      linux: {
        '.deb': _installerDeb.default,
        '.rpm': _installerRpm.default
      }
    };
    const suffixFnIdent = Object.keys(installActions[process.platform]).find(suffix => targetAsset.name.endsWith(suffix));

    if (!suffixFnIdent) {
      throw new Error(`No installer to handle "${targetAsset.name}"`);
    }

    const InstallerClass = installActions[process.platform][suffixFnIdent];
    const installer = new InstallerClass();
    await installer.install({
      installSpinner,
      filePath: fullFilePath
    });
  });
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvaW5zdGFsbC50cyJdLCJuYW1lcyI6WyJudWdnZXQiLCJyZXF1aXJlIiwiZCIsIkdJVEhVQl9BUEkiLCJJbnN0YWxsZXJJbXBsIiwiSW5zdGFsbGVyQmFzZSIsImludGVyYWN0aXZlIiwicHJlcmVsZWFzZSIsInJlcG8iLCJjaG9vc2VBc3NldCIsImFzeW5jT3JhIiwiRXJyb3IiLCJsYXRlc3RSZWxlYXNlIiwicG9zc2libGVBc3NldHMiLCJzZWFyY2hTcGlubmVyIiwiaW5jbHVkZXMiLCJyZWxlYXNlcyIsImpzb24iLCJlcnIiLCJtZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZmlsdGVyIiwicmVsZWFzZSIsInNvcnRlZFJlbGVhc2VzIiwic29ydCIsInJlbGVhc2VBIiwicmVsZWFzZUIiLCJ0YWdBIiwidGFnX25hbWUiLCJzdWJzdHIiLCJ0YWdCIiwic2VtdmVyIiwiZ3QiLCJ0ZXh0IiwiYXNzZXRzIiwiaW5zdGFsbFRhcmdldHMiLCJ3aW4zMiIsImRhcndpbiIsImxpbnV4IiwiYXNzZXQiLCJ0YXJnZXRTdWZmaXhlcyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInN1ZmZpeCIsInRlc3QiLCJuYW1lIiwiY3lhbiIsInRhcmdldEFzc2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0bXBkaXIiLCJwYXRoIiwib3MiLCJwYXRoU2FmZVJlcG8iLCJyZXBsYWNlIiwiZmlsZW5hbWUiLCJmdWxsRmlsZVBhdGgiLCJmcyIsInBhdGhFeGlzdHMiLCJzdGF0Iiwic2l6ZSIsIm1rZGlycyIsIm51Z2dldE9wdHMiLCJ0YXJnZXQiLCJkaXIiLCJyZXN1bWUiLCJzdHJpY3RTU0wiLCJicm93c2VyX2Rvd25sb2FkX3VybCIsImluc3RhbGxTcGlubmVyIiwiaW5zdGFsbEFjdGlvbnMiLCJFeGVJbnN0YWxsZXIiLCJaaXBJbnN0YWxsZXIiLCJETUdJbnN0YWxsZXIiLCJEZWJJbnN0YWxsZXIiLCJSUE1JbnN0YWxsZXIiLCJzdWZmaXhGbklkZW50IiwiT2JqZWN0Iiwia2V5cyIsImZpbmQiLCJlbmRzV2l0aCIsIkluc3RhbGxlckNsYXNzIiwiaW5zdGFsbGVyIiwiaW5zdGFsbCIsImZpbGVQYXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7O0FBRUEsTUFBTUEsTUFBTSxHQUFHQyxPQUFPLENBQUMsUUFBRCxDQUF0Qjs7QUFFQSxNQUFNQyxDQUFDLEdBQUcsb0JBQU0sd0JBQU4sQ0FBVjtBQUVBLE1BQU1DLFVBQVUsR0FBRyx3QkFBbkI7O0FBRUEsTUFBTUMsYUFBTixTQUE0QkMsc0JBQTVCLENBQTBDO0FBQUE7QUFBQTs7QUFBQSxrQ0FBUyxNQUFUO0FBQUE7O0FBQUE7O2VBcUMzQixPQUFPO0FBQ3BCQyxFQUFBQSxXQUFXLEdBQUcsS0FETTtBQUVwQkMsRUFBQUEsVUFBVSxHQUFHLEtBRk87QUFHcEJDLEVBQUFBLElBSG9CO0FBSXBCQyxFQUFBQTtBQUpvQixDQUFQLEtBS087QUFDcEJDLHFCQUFTSixXQUFULEdBQXVCQSxXQUF2Qjs7QUFFQSxNQUFJLE9BQU9HLFdBQVAsS0FBdUIsVUFBM0IsRUFBdUM7QUFDckMsVUFBTSxJQUFJRSxLQUFKLENBQVUsdURBQVYsQ0FBTjtBQUNEOztBQUVELE1BQUlDLGFBQUo7QUFDQSxNQUFJQyxjQUF1QixHQUFHLEVBQTlCO0FBRUEsUUFBTSx3QkFBUywyQkFBVCxFQUFzQyxNQUFPQyxhQUFQLElBQXlCO0FBQ25FLFFBQUksQ0FBQ04sSUFBRCxJQUFTLENBQUNBLElBQUksQ0FBQ08sUUFBTCxDQUFjLEdBQWQsQ0FBZCxFQUFrQztBQUNoQyxZQUFNLElBQUlKLEtBQUosQ0FBVSwyREFBVixDQUFOO0FBQ0Q7O0FBRURULElBQUFBLENBQUMsQ0FBQyxxQkFBRCxFQUF3Qk0sSUFBeEIsQ0FBRDtBQUNBLFFBQUlRLFFBQUo7O0FB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bnQiOlsiaW1wb3J0ICdjb2xvcnMnO1xuaW1wb3J0IHsgYXN5bmNPcmEgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCBJbnN0YWxsZXJCYXNlIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9pbnN0YWxsZXItYmFzZSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5pbXBvcnQgRE1HSW5zdGFsbGVyIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9pbnN0YWxsZXItZG1nJztcbmltcG9ydCBaaXBJbnN0YWxsZXIgZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2luc3RhbGxlci16aXAnO1xuaW1wb3J0IERlYkluc3RhbGxlciBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvaW5zdGFsbGVyLWRlYic7XG5pbXBvcnQgUlBNSW5zdGFsbGVyIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9pbnN0YWxsZXItcnBtJztcbmltcG9ydCBFeGVJbnN0YWxsZXIgZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2luc3RhbGxlci1leGUnO1xuXG5pbXBvcnQgeyBpbmZvIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5cbmNvbnN0IG51Z2dldCA9IHJlcXVpcmUoJ251Z2dldCcpO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOmluc3RhbGwnKTtcblxuY29uc3QgR0lUSFVCX0FQSSA9ICdodHRwczovL2FwaS5naXRodWIuY29tJztcblxuY2xhc3MgSW5zdGFsbGVySW1wbCBleHRlbmRzIEluc3RhbGxlckJhc2UgeyBuYW1lID0gJ2ltcGwnOyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzZXQge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHNpemU6IG51bWJlcjtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICBicm93c2VyX2Rvd25sb2FkX3VybDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVsZWFzZSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgdGFnX25hbWU6IHN0cmluZztcbiAgcHJlcmVsZWFzZTogYm9vbGVhbjtcbiAgYXNzZXRzOiBBc3NldFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbGxPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdXNlIHNlbnNpYmxlIGRlZmF1bHRzIG9yIHByb21wdCB0aGUgdXNlciB2aXN1YWxseVxuICAgKi9cbiAgaW50ZXJhY3RpdmU/OiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0byBpbnN0YWxsIHByZXJlbGVhc2UgdmVyc2lvbnNcbiAgICovXG4gIHByZXJlbGVhc2U/OiBib29sZWFuO1xuICAvKipcbiAgICogVGhlIEdpdEh1YiByZXBvc2l0b3J5IHRvIGluc3RhbGwgZnJvbSwgaW4gdGhlIGZvcm1hdCBvd25lci9uYW1lXG4gICAqL1xuICByZXBvOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gdGhlIGFzc2V0IHRvIHVzZS9pbnN0YWxsIGZyb20gYSBwcm92aWRlZCBhcnJheSBvZiBjb21wYXRpYmxlXG4gICAqIEdpdEh1YiBhc3NldHMuXG4gICAqL1xuICBjaG9vc2VBc3NldDogKGFzc2V0czogQXNzZXRbXSkgPT4gUHJvbWlzZTxBc3NldD4gfCBBc3NldDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHtcbiAgaW50ZXJhY3RpdmUgPSBmYWxzZSxcbiAgcHJlcmVsZWFzZSA9IGZhbHNlLFxuICByZXBvLFxuICBjaG9vc2VBc3NldCxcbn06IEluc3RhbGxPcHRpb25zKSA9PiB7XG4gIGFzeW5jT3JhLmludGVyYWN0aXZlID0gaW50ZXJhY3RpdmU7XG5cbiAgaWYgKHR5cGVvZiBjaG9vc2VBc3NldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY2hvb3NlQXNzZXQgdG8gYmUgYSBmdW5jdGlvbiBpbiBpbnN0YWxsIGNhbGwnKTtcbiAgfVxuXG4gIGxldCBsYXRlc3RSZWxlYXNlITogUmVsZWFzZTtcbiAgbGV0IHBvc3NpYmxlQXNzZXRzOiBBc3NldFtdID0gW107XG5cbiAgYXdhaXQgYXN5bmNPcmEoJ1NlYXJjaGluZyBmb3IgQXBwbGljYXRpb24nLCBhc3luYyAoc2VhcmNoU3Bpbm5lcikgPT4ge1xuICAgIGlmICghcmVwbyB8fCAhcmVwby5pbmNsdWRlcygnLycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVwb3NpdG9yeSBuYW1lLCBtdXN0IGJlIGluIHRoZSBmb3JtYXQgb3duZXIvbmFtZScpO1xuICAgIH1cblxuICAgIGQoJ3NlYXJjaGluZyBmb3IgcmVwbzonLCByZXBvKTtcbiAgICBsZXQgcmVsZWFzZXMhOiBSZWxlYXNlW107XG4gICAgdHJ5IHtcbiAgICAgIHJlbGVhc2VzID0gYXdhaXQgKGF3YWl0IGZldGNoKGAke0dJVEhVQl9BUEl9L3JlcG9zLyR7cmVwb30vcmVsZWFzZXNgKSkuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgfVxuXG4gICAgaWYgKCFyZWxlYXNlcyB8fCAocmVsZWFzZXMgYXMgYW55KS5tZXNzYWdlID09PSAnTm90IEZvdW5kJyB8fCAhQXJyYXkuaXNBcnJheShyZWxlYXNlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgcmVsZWFzZXMgZm9yIHJlcG9zaXRvcnkgXCIke3JlcG99XCIuICBQbGVhc2UgY2hlY2sgdGhlIG5hbWUgYW5kIHRyeSBhZ2Fpbi5gKTtcbiAgICB9XG5cbiAgICBpZiAocmVsZWFzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcG9zaXRvcnkgXCIke3JlcG99XCIgaGFzIG5vIHJlbGVhc2VzYCk7XG4gICAgfVxuXG4gICAgcmVsZWFzZXMgPSByZWxlYXNlcy5maWx0ZXIoKHJlbGVhc2UpID0+ICFyZWxlYXNlLnByZXJlbGVhc2UgfHwgcHJlcmVsZWFzZSk7XG5cbiAgICBjb25zdCBzb3J0ZWRSZWxlYXNlcyA9IHJlbGVhc2VzLnNvcnQoKHJlbGVhc2VBLCByZWxlYXNlQikgPT4ge1xuICAgICAgbGV0IHRhZ0EgPSByZWxlYXNlQS50YWdfbmFtZTtcbiAgICAgIGlmICh0YWdBLnN1YnN0cigwLCAxKSA9PT0gJ3YnKSB0YWdBID0gdGFnQS5zdWJzdHIoMSk7XG4gICAgICBsZXQgdGFnQiA9IHJlbGVhc2VCLnRhZ19uYW1lO1xuICAgICAgaWYgKHRhZ0Iuc3Vic3RyKDAsIDEpID09PSAndicpIHRhZ0IgPSB0YWdCLnN1YnN0cigxKTtcbiAgICAgIHJldHVybiAoc2VtdmVyLmd0KHRhZ0IsIHRhZ0EpID8gMSA6IC0xKTtcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICBsYXRlc3RSZWxlYXNlID0gc29ydGVkUmVsZWFzZXNbMF07XG5cbiAgICBzZWFyY2hTcGlubmVyLnRleHQgPSAnU2VhcmNoaW5nIGZvciBSZWxlYXNlcyc7XG5cbiAgICBjb25zdCB7IGFzc2V0cyB9ID0gbGF0ZXN0UmVsZWFzZTtcbiAgICBpZiAoIWFzc2V0cyB8fCAhQXJyYXkuaXNBcnJheShhc3NldHMpIHx8IGFzc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYW55IGFzc2V0cyBmb3IgdGhlIGxhdGVzdCByZWxlYXNlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFsbFRhcmdldHM6IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IFJlZ0V4cFtdO1xuICAgIH0gPSB7XG4gICAgICB3aW4zMjogWy9cXC5leGUkL10sXG4gICAgICBkYXJ3aW46IFsvT1NYLipcXC56aXAkLywgL2Rhcndpbi4qXFwuemlwJC8sIC9tYWNPUy4qXFwuemlwJC8sIC9tYWMuKlxcLnppcCQvLCAvXFwuZG1nJC9dLFxuICAgICAgbGludXg6IFsvXFwucnBtJC8sIC9cXC5kZWIkL10sXG4gICAgfTtcblxuICAgIHBvc3NpYmxlQXNzZXRzID0gYXNzZXRzLmZpbHRlcigoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldFN1ZmZpeGVzID0gaW5zdGFsbFRhcmdldHNbcHJvY2Vzcy5wbGF0Zm9ybV07XG4gICAgICBmb3IgKGNvbnN0IHN1ZmZpeCBvZiB0YXJnZXRTdWZmaXhlcykge1xuICAgICAgICBpZiAoc3VmZml4LnRlc3QoYXNzZXQubmFtZSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgaWYgKHBvc3NpYmxlQXNzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhbnkgaW5zdGFsbGFibGUgYXNzZXRzIGZvciB0YXJnZXQgcGxhdGZvcm06ICR7YCR7cHJvY2Vzcy5wbGF0Zm9ybX1gLmN5YW59YCk7XG4gICAgfVxuICB9KTtcblxuICBpbmZvKGludGVyYWN0aXZlLCBgRm91bmQgbGF0ZXN0IHJlbGVhc2Uke3ByZXJlbGVhc2UgPyAnIChpbmNsdWRpbmcgcHJlcmVsZWFzZXMpJyA6ICcnfTogJHtsYXRlc3RSZWxlYXNlLnRhZ19uYW1lLmN5YW59YCk7XG5cbiAgbGV0IHRhcmdldEFzc2V0ID0gcG9zc2libGVBc3NldHNbMF07XG4gIGlmIChwb3NzaWJsZUFzc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgdGFyZ2V0QXNzZXQgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoY2hvb3NlQXNzZXQocG9zc2libGVBc3NldHMpKTtcbiAgfVxuXG4gIGNvbnN0IHRtcGRpciA9IHBhdGgucmVzb2x2ZShvcy50bXBkaXIoKSwgJ2ZvcmdlLWluc3RhbGwnKTtcbiAgY29uc3QgcGF0aFNhZmVSZXBvID0gcmVwby5yZXBsYWNlKC9bL1xcXFxdL2csICctJyk7XG4gIGNvbnN0IGZpbGVuYW1lID0gYCR7cGF0aFNhZmVSZXBvfS0ke2xhdGVzdFJlbGVhc2UudGFnX25hbWV9LSR7dGFyZ2V0QXNzZXQubmFtZX1gO1xuXG4gIGNvbnN0IGZ1bGxGaWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0bXBkaXIsIGZpbGVuYW1lKTtcbiAgaWYgKCFhd2FpdCBmcy5wYXRoRXhpc3RzKGZ1bGxGaWxlUGF0aClcbiAgICAgIHx8IChhd2FpdCBmcy5zdGF0KGZ1bGxGaWxlUGF0aCkpLnNpemUgIT09IHRhcmdldEFzc2V0LnNpemUpIHtcbiAgICBhd2FpdCBmcy5ta2RpcnModG1wZGlyKTtcblxuICAgIGNvbnN0IG51Z2dldE9wdHMgPSB7XG4gICAgICB0YXJnZXQ6IGZpbGVuYW1lLFxuICAgICAgZGlyOiB0bXBkaXIsXG4gICAgICByZXN1bWU6IHRydWUsXG4gICAgICBzdHJpY3RTU0w6IHRydWUsXG4gICAgfTtcbiAgICBhd2FpdCBwcm9taXNpZnkobnVnZ2V0KSh0YXJnZXRBc3NldC5icm93c2VyX2Rvd25sb2FkX3VybCwgbnVnZ2V0T3B0cyk7XG4gIH1cblxuICBhd2FpdCBhc3luY09yYSgnSW5zdGFsbGluZyBBcHBsaWNhdGlvbicsIGFzeW5jIChpbnN0YWxsU3Bpbm5lcikgPT4ge1xuICAgIGNvbnN0IGluc3RhbGxBY3Rpb25zOiB7XG4gICAgICBba2V5OiBzdHJpbmddOiB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IHR5cGVvZiBJbnN0YWxsZXJJbXBsO1xuICAgICAgfTtcbiAgICB9ID0ge1xuICAgICAgd2luMzI6IHtcbiAgICAgICAgJy5leGUnOiBFeGVJbnN0YWxsZXIsXG4gICAgICB9LFxuICAgICAgZGFyd2luOiB7XG4gICAgICAgICcuemlwJzogWmlwSW5zdGFsbGVyLFxuICAgICAgICAnLmRtZyc6IERNR0luc3RhbGxlcixcbiAgICAgIH0sXG4gICAgICBsaW51eDoge1xuICAgICAgICAnLmRlYic6IERlYkluc3RhbGxlcixcbiAgICAgICAgJy5ycG0nOiBSUE1JbnN0YWxsZXIsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCBzdWZmaXhGbklkZW50ID0gT2JqZWN0LmtleXMoaW5zdGFsbEFjdGlvbnNbcHJvY2Vzcy5wbGF0Zm9ybV0pXG4gICAgICAuZmluZCgoc3VmZml4KSA9PiB0YXJnZXRBc3NldC5uYW1lLmVuZHNXaXRoKHN1ZmZpeCkpO1xuICAgIGlmICghc3VmZml4Rm5JZGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbnN0YWxsZXIgdG8gaGFuZGxlIFwiJHt0YXJnZXRBc3NldC5uYW1lfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IEluc3RhbGxlckNsYXNzID0gaW5zdGFsbEFjdGlvbnNbcHJvY2Vzcy5wbGF0Zm9ybV1bc3VmZml4Rm5JZGVudF07XG4gICAgY29uc3QgaW5zdGFsbGVyID0gbmV3IEluc3RhbGxlckNsYXNzKCk7XG4gICAgYXdhaXQgaW5zdGFsbGVyLmluc3RhbGwoeyBpbnN0YWxsU3Bpbm5lciwgZmlsZVBhdGg6IGZ1bGxGaWxlUGF0aCB9KTtcbiAgfSk7XG59O1xuIl19