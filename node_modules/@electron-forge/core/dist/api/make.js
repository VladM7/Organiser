"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _get = require("@electron/get");

var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));

var _hook = require("../util/hook");

var _messages = require("../util/messages");

var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));

var _readPackageJson = require("../util/read-package-json");

var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));

var _outDir = _interopRequireDefault(require("../util/out-dir"));

var _electronVersion = require("../util/electron-version");

var _requireSearch = _interopRequireDefault(require("../util/require-search"));

var _package = _interopRequireDefault(require("./package"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class MakerImpl extends _makerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'impl');

    _defineProperty(this, "defaultPlatforms", []);
  }

}

function generateTargets(forgeConfig, overrideTargets) {
  if (overrideTargets) {
    return overrideTargets.map(target => {
      if (typeof target === 'string') {
        return forgeConfig.makers.find(maker => maker.name === target) || {
          name: target
        };
      }

      return target;
    });
  }

  return forgeConfig.makers;
}

var _default = async ({
  dir = process.cwd(),
  interactive = false,
  skipPackage = false,
  arch = (0, _get.getHostArch)(),
  platform = process.platform,
  overrideTargets,
  outDir
}) => {
  _asyncOra.asyncOra.interactive = interactive;
  let forgeConfig;
  await (0, _asyncOra.asyncOra)('Resolving Forge Config', async () => {
    const resolvedDir = await (0, _resolveDir.default)(dir);

    if (!resolvedDir) {
      throw new Error('Failed to locate makeable Electron application');
    }

    dir = resolvedDir;
    forgeConfig = await (0, _forgeConfig.default)(dir);
  });
  const actualOutDir = outDir || (0, _outDir.default)(dir, forgeConfig);
  const actualTargetPlatform = platform;
  platform = platform === 'mas' ? 'darwin' : platform;

  if (!['darwin', 'win32', 'linux', 'mas'].includes(actualTargetPlatform)) {
    throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'`);
  }

  const makers = {};
  let targets = generateTargets(forgeConfig, overrideTargets);
  let targetId = 0;

  for (const target of targets) {
    let maker; // eslint-disable-next-line no-underscore-dangle

    if (target.__isElectronForgeMaker) {
      maker = target; // eslint-disable-next-line no-continue

      if (!maker.platforms.includes(actualTargetPlatform)) continue;
    } else {
      const resolvableTarget = target;

      if (!resolvableTarget.name) {
        throw new Error(`The following maker config is missing a maker name: ${JSON.stringify(resolvableTarget)}`);
      } else if (typeof resolvableTarget.name !== 'string') {
        throw new Error(`The following maker config has a maker name that is not a string: ${JSON.stringify(resolvableTarget)}`);
      }

      const MakerClass = (0, _requireSearch.default)(dir, [resolvableTarget.name]);

      if (!MakerClass) {
        throw new Error(`Could not find module with name: ${resolvableTarget.name}. Make sure it's listed in the devDependencies of your package.json`);
      }

      maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined); // eslint-disable-next-line no-continue

      if (!maker.platforms.includes(actualTargetPlatform)) continue;
    }

    if (!maker.isSupportedOnCurrentPlatform) {
      throw new Error([`Maker for target ${maker.name} is incompatible with this version of `, 'electron-forge, please upgrade or contact the maintainer ', '(needs to implement \'isSupportedOnCurrentPlatform)\')'].join(''));
    }

    if (!(await maker.isSupportedOnCurrentPlatform())) {
      throw new Error([`Cannot make for ${platform} and target ${maker.name}: the maker declared `, `that it cannot run on ${process.platform}`].join(''));
    }

    maker.ensureExternalBinariesExist();
    makers[targetId] = maker;
    targetId += 1;
  }

  if (!skipPackage) {
    (0, _messages.info)(interactive, 'We need to package your application before we can make it'.green);
    await (0, _package.default)({
      dir,
      interactive,
      arch,
      outDir: actualOutDir,
      platform: actualTargetPlatform
    });
  } else {
    (0, _messages.warn)(interactive, 'WARNING: Skipping the packaging step, this could result in an out of date build'.red);
  }

  targets = targets.filter((_, i) => makers[i]);

  if (targets.length === 0) {
    throw new Error(`Could not find any make targets configured for the "${actualTargetPlatform}" platform.`);
  }

  (0, _messages.info)(interactive, `Making for the following targets: ${`${targets.map((t, i) => makers[i].name).join(', ')}`.cyan}`);
  const packageJSON = await (0, _readPackageJson.readMutatedPackageJson)(dir, forgeConfig);
  const appName = forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name;
  const outputs = [];
  await (0, _hook.runHook)(forgeConfig, 'preMake');

  for (const targetArch of (0, _parseArchs.default)(platform, arch, await (0, _electronVersion.getElectronVersion)(dir, packageJSON))) {
    const packageDir = _path.default.resolve(actualOutDir, `${appName}-${actualTargetPlatform}-${targetArch}`);

    if (!(await _fsExtra.default.pathExists(packageDir))) {
      throw new Error(`Couldn't find packaged app at: ${packageDir}`);
    }

    targetId = 0; // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-unused-vars

    for (const _target of targets) {
      const maker = makers[targetId];
      targetId += 1; // eslint-disable-next-line no-loop-func

      await (0, _asyncOra.asyncOra)(`Making for target: ${maker.name.green} - On platform: ${actualTargetPlatform.cyan} - For arch: ${targetArch.cyan}`, async () => {
        try {
          /**
           * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
           *
           * Currently it is assumed we have 1 maker per make call but that is
           * not enforced.  It is technically possible to have 1 maker be called
           * multiple times.  The "prepareConfig" method however implicitly
           * requires a lock that is not enforced.  There are two options:
           *
           *   * Provide makers a getConfig() method
           *   * Remove support for config being provided as a method
           *   * Change the entire API of maker from a single constructor to
           *     providing a MakerFactory
           */
          maker.prepareConfig(targetArch);
          const artifacts = await maker.make({
            appName,
            forgeConfig,
            packageJSON,
            targetArch,
            dir: packageDir,
            makeDir: _path.default.resolve(actualOutDir, 'make'),
            targetPlatform: actualTargetPlatform
          });
          outputs.push({
            artifacts,
            packageJSON,
            platform: actualTargetPlatform,
            arch: targetArch
          });
        } catch (err) {
          if (err instanceof Error) {
            // eslint-disable-next-line no-throw-literal
            throw {
              message: `An error occured while making for target: ${maker.name}`,
              stack: `${err.message}\n${err.stack}`
            };
          } else if (err) {
            throw err;
          } else {
            throw new Error(`An unknown error occured while making for target: ${maker.name}`);
          }
        }
      });
    }
  } // If the postMake hooks modifies the locations / names of the outputs it must return
  // the new locations so that the publish step knows where to look


  return (0, _hook.runMutatingHook)(forgeConfig, 'postMake', outputs);
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJuYW1lcyI6WyJNYWtlckltcGwiLCJNYWtlckJhc2UiLCJnZW5lcmF0ZVRhcmdldHMiLCJmb3JnZUNvbmZpZyIsIm92ZXJyaWRlVGFyZ2V0cyIsIm1hcCIsInRhcmdldCIsIm1ha2VycyIsImZpbmQiLCJtYWtlciIsIm5hbWUiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJza2lwUGFja2FnZSIsImFyY2giLCJwbGF0Zm9ybSIsIm91dERpciIsImFzeW5jT3JhIiwicmVzb2x2ZWREaXIiLCJFcnJvciIsImFjdHVhbE91dERpciIsImFjdHVhbFRhcmdldFBsYXRmb3JtIiwiaW5jbHVkZXMiLCJ0YXJnZXRzIiwidGFyZ2V0SWQiLCJfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyIiwicGxhdGZvcm1zIiwicmVzb2x2YWJsZVRhcmdldCIsIkpTT04iLCJzdHJpbmdpZnkiLCJNYWtlckNsYXNzIiwiY29uZmlnIiwidW5kZWZpbmVkIiwiaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSIsImpvaW4iLCJlbnN1cmVFeHRlcm5hbEJpbmFyaWVzRXhpc3QiLCJncmVlbiIsInJlZCIsImZpbHRlciIsIl8iLCJpIiwibGVuZ3RoIiwidCIsImN5YW4iLCJwYWNrYWdlSlNPTiIsImFwcE5hbWUiLCJwYWNrYWdlckNvbmZpZyIsInByb2R1Y3ROYW1lIiwib3V0cHV0cyIsInRhcmdldEFyY2giLCJwYWNrYWdlRGlyIiwicGF0aCIsInJlc29sdmUiLCJmcyIsInBhdGhFeGlzdHMiLCJfdGFyZ2V0IiwicHJlcGFyZUNvbmZpZyIsImFydGlmYWN0cyIsIm1ha2UiLCJtYWtlRGlyIiwidGFyZ2V0UGxhdGZvcm0iLCJwdXNoIiwiZXJyIiwibWVzc2FnZSIsInN0YWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFD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Zm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCB7IGdldEhvc3RBcmNoIH0gZnJvbSAnQGVsZWN0cm9uL2dldCc7XG5pbXBvcnQge1xuICBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIsIEZvcmdlQ29uZmlnLCBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0sIEZvcmdlTWFrZVJlc3VsdCxcbn0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgTWFrZXJCYXNlIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9tYWtlci1iYXNlJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IGdldEZvcmdlQ29uZmlnIGZyb20gJy4uL3V0aWwvZm9yZ2UtY29uZmlnJztcbmltcG9ydCB7IHJ1bkhvb2ssIHJ1bk11dGF0aW5nSG9vayB9IGZyb20gJy4uL3V0aWwvaG9vayc7XG5pbXBvcnQgeyBpbmZvLCB3YXJuIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5pbXBvcnQgcGFyc2VBcmNocyBmcm9tICcuLi91dGlsL3BhcnNlLWFyY2hzJztcbmltcG9ydCB7IHJlYWRNdXRhdGVkUGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCByZXNvbHZlRGlyIGZyb20gJy4uL3V0aWwvcmVzb2x2ZS1kaXInO1xuaW1wb3J0IGdldEN1cnJlbnRPdXREaXIgZnJvbSAnLi4vdXRpbC9vdXQtZGlyJztcbmltcG9ydCB7IGdldEVsZWN0cm9uVmVyc2lvbiB9IGZyb20gJy4uL3V0aWwvZWxlY3Ryb24tdmVyc2lvbic7XG5pbXBvcnQgcmVxdWlyZVNlYXJjaCBmcm9tICcuLi91dGlsL3JlcXVpcmUtc2VhcmNoJztcblxuaW1wb3J0IHBhY2thZ2VyIGZyb20gJy4vcGFja2FnZSc7XG5cbmNsYXNzIE1ha2VySW1wbCBleHRlbmRzIE1ha2VyQmFzZTxhbnk+IHtcbiAgbmFtZSA9ICdpbXBsJztcblxuICBkZWZhdWx0UGxhdGZvcm1zID0gW107XG59XG5cbnR5cGUgTWFrZVRhcmdldCA9IElGb3JnZVJlc29sdmFibGVNYWtlciB8IE1ha2VyQmFzZTxhbnk+IHwgc3RyaW5nO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRhcmdldHMoZm9yZ2VDb25maWc6IEZvcmdlQ29uZmlnLCBvdmVycmlkZVRhcmdldHM/OiBNYWtlVGFyZ2V0W10pIHtcbiAgaWYgKG92ZXJyaWRlVGFyZ2V0cykge1xuICAgIHJldHVybiBvdmVycmlkZVRhcmdldHMubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZm9yZ2VDb25maWcubWFrZXJzLmZpbmQoXG4gICAgICAgICAgKG1ha2VyKSA9PiAobWFrZXIgYXMgSUZvcmdlUmVzb2x2YWJsZU1ha2VyKS5uYW1lID09PSB0YXJnZXQsXG4gICAgICAgICkgfHwgeyBuYW1lOiB0YXJnZXQgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZm9yZ2VDb25maWcubWFrZXJzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ha2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBhcHAgZnJvbSB3aGljaCBkaXN0cnVidXRhYmxlcyBhcmUgZ2VuZXJhdGVkXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2tpcCB0aGUgcHJlLW1ha2UgcGFja2FnaW5nIHN0ZXBcbiAgICovXG4gIHNraXBQYWNrYWdlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIG1ha2UgdGFyZ2V0cyB0byBvdmVycmlkZSB5b3VyIGZvcmdlIGNvbmZpZ1xuICAgKi9cbiAgb3ZlcnJpZGVUYXJnZXRzPzogTWFrZVRhcmdldFtdO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBhcmNoaXRlY3R1cmVcbiAgICovXG4gIGFyY2g/OiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHBsYXRmb3JtXG4gICAqL1xuICBwbGF0Zm9ybT86IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIGRpc3RyaWJ1dGFibGVzXG4gICAqL1xuICBvdXREaXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7XG4gIGRpciA9IHByb2Nlc3MuY3dkKCksXG4gIGludGVyYWN0aXZlID0gZmFsc2UsXG4gIHNraXBQYWNrYWdlID0gZmFsc2UsXG4gIGFyY2ggPSBnZXRIb3N0QXJjaCgpIGFzIEZvcmdlQXJjaCxcbiAgcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtIGFzIEZvcmdlUGxhdGZvcm0sXG4gIG92ZXJyaWRlVGFyZ2V0cyxcbiAgb3V0RGlyLFxufTogTWFrZU9wdGlvbnMpID0+IHtcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBsZXQgZm9yZ2VDb25maWchOiBGb3JnZUNvbmZpZztcbiAgYXdhaXQgYXN5bmNPcmEoJ1Jlc29sdmluZyBGb3JnZSBDb25maWcnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWREaXIgPSBhd2FpdCByZXNvbHZlRGlyKGRpcik7XG4gICAgaWYgKCFyZXNvbHZlZERpcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9jYXRlIG1ha2VhYmxlIEVsZWN0cm9uIGFwcGxpY2F0aW9uJyk7XG4gICAgfVxuICAgIGRpciA9IHJlc29sdmVkRGlyO1xuXG4gICAgZm9yZ2VDb25maWcgPSBhd2FpdCBnZXRGb3JnZUNvbmZpZyhkaXIpO1xuICB9KTtcblxuICBjb25zdCBhY3R1YWxPdXREaXIgPSBvdXREaXIgfHwgZ2V0Q3VycmVudE91dERpcihkaXIsIGZvcmdlQ29uZmlnKTtcblxuICBjb25zdCBhY3R1YWxUYXJnZXRQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICBwbGF0Zm9ybSA9IHBsYXRmb3JtID09PSAnbWFzJyA/ICdkYXJ3aW4nIDogcGxhdGZvcm07XG4gIGlmICghWydkYXJ3aW4nLCAnd2luMzInLCAnbGludXgnLCAnbWFzJ10uaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHthY3R1YWxUYXJnZXRQbGF0Zm9ybX0nIGlzIGFuIGludmFsaWQgcGxhdGZvcm0uIENob2ljZXMgYXJlICdkYXJ3aW4nLCAnbWFzJywgJ3dpbjMyJyBvciAnbGludXgnYCk7XG4gIH1cblxuICBjb25zdCBtYWtlcnM6IHtcbiAgICBba2V5OiBudW1iZXJdOiBNYWtlckJhc2U8YW55PjtcbiAgfSA9IHt9O1xuXG4gIGxldCB0YXJnZXRzID0gZ2VuZXJhdGVUYXJnZXRzKGZvcmdlQ29uZmlnLCBvdmVycmlkZVRhcmdldHMpO1xuXG4gIGxldCB0YXJnZXRJZCA9IDA7XG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBsZXQgbWFrZXI6IE1ha2VyQmFzZTxhbnk+O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIGlmICgodGFyZ2V0IGFzIE1ha2VyQmFzZTxhbnk+KS5fX2lzRWxlY3Ryb25Gb3JnZU1ha2VyKSB7XG4gICAgICBtYWtlciA9IHRhcmdldCBhcyBNYWtlckJhc2U8YW55PjtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgaWYgKCFtYWtlci5wbGF0Zm9ybXMuaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzb2x2YWJsZVRhcmdldDogSUZvcmdlUmVzb2x2YWJsZU1ha2VyID0gdGFyZ2V0IGFzIElGb3JnZVJlc29sdmFibGVNYWtlcjtcblxuICAgICAgaWYgKCFyZXNvbHZhYmxlVGFyZ2V0Lm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIG1ha2VyIGNvbmZpZyBpcyBtaXNzaW5nIGEgbWFrZXIgbmFtZTogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZhYmxlVGFyZ2V0KX1gKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc29sdmFibGVUYXJnZXQubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIG1ha2VyIGNvbmZpZyBoYXMgYSBtYWtlciBuYW1lIHRoYXQgaXMgbm90IGEgc3RyaW5nOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmFibGVUYXJnZXQpfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBNYWtlckNsYXNzID0gcmVxdWlyZVNlYXJjaDx0eXBlb2YgTWFrZXJJbXBsPihkaXIsIFtyZXNvbHZhYmxlVGFyZ2V0Lm5hbWVdKTtcbiAgICAgIGlmICghTWFrZXJDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG1vZHVsZSB3aXRoIG5hbWU6ICR7cmVzb2x2YWJsZVRhcmdldC5uYW1lfS4gTWFrZSBzdXJlIGl0J3MgbGlzdGVkIGluIHRoZSBkZXZEZXBlbmRlbmNpZXMgb2YgeW91ciBwYWNrYWdlLmpzb25gKTtcbiAgICAgIH1cblxuICAgICAgbWFrZXIgPSBuZXcgTWFrZXJDbGFzcyhyZXNvbHZhYmxlVGFyZ2V0LmNvbmZpZywgcmVzb2x2YWJsZVRhcmdldC5wbGF0Zm9ybXMgfHwgdW5kZWZpbmVkKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgaWYgKCFtYWtlci5wbGF0Zm9ybXMuaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1ha2VyLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGBNYWtlciBmb3IgdGFyZ2V0ICR7bWFrZXIubmFtZX0gaXMgaW5jb21wYXRpYmxlIHdpdGggdGhpcyB2ZXJzaW9uIG9mIGAsXG4gICAgICAgICdlbGVjdHJvbi1mb3JnZSwgcGxlYXNlIHVwZ3JhZGUgb3IgY29udGFjdCB0aGUgbWFpbnRhaW5lciAnLFxuICAgICAgICAnKG5lZWRzIHRvIGltcGxlbWVudCBcXCdpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKVxcJyknLFxuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFhd2FpdCBtYWtlci5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGBDYW5ub3QgbWFrZSBmb3IgJHtwbGF0Zm9ybX0gYW5kIHRhcmdldCAke21ha2VyLm5hbWV9OiB0aGUgbWFrZXIgZGVjbGFyZWQgYCxcbiAgICAgICAgYHRoYXQgaXQgY2Fubm90IHJ1biBvbiAke3Byb2Nlc3MucGxhdGZvcm19YCxcbiAgICAgIF0uam9pbignJykpO1xuICAgIH1cblxuICAgIG1ha2VyLmVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCgpO1xuXG4gICAgbWFrZXJzW3RhcmdldElkXSA9IG1ha2VyO1xuICAgIHRhcmdldElkICs9IDE7XG4gIH1cblxuICBpZiAoIXNraXBQYWNrYWdlKSB7XG4gICAgaW5mbyhpbnRlcmFjdGl2ZSwgJ1dlIG5lZWQgdG8gcGFja2FnZSB5b3VyIGFwcGxpY2F0aW9uIGJlZm9yZSB3ZSBjYW4gbWFrZSBpdCcuZ3JlZW4pO1xuICAgIGF3YWl0IHBhY2thZ2VyKHtcbiAgICAgIGRpcixcbiAgICAgIGludGVyYWN0aXZlLFxuICAgICAgYXJjaCxcbiAgICAgIG91dERpcjogYWN0dWFsT3V0RGlyLFxuICAgICAgcGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdhcm4oaW50ZXJhY3RpdmUsICdXQVJOSU5HOiBTa2lwcGluZyB0aGUgcGFja2FnaW5nIHN0ZXAsIHRoaXMgY291bGQgcmVzdWx0IGluIGFuIG91dCBvZiBkYXRlIGJ1aWxkJy5yZWQpO1xuICB9XG5cbiAgdGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKChfLCBpKSA9PiBtYWtlcnNbaV0pO1xuXG4gIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IG1ha2UgdGFyZ2V0cyBjb25maWd1cmVkIGZvciB0aGUgXCIke2FjdHVhbFRhcmdldFBsYXRmb3JtfVwiIHBsYXRmb3JtLmApO1xuICB9XG5cbiAgaW5mbyhpbnRlcmFjdGl2ZSwgYE1ha2luZyBmb3IgdGhlIGZvbGxvd2luZyB0YXJnZXRzOiAke2Ake3RhcmdldHMubWFwKCh0LCBpKSA9PiBtYWtlcnNbaV0ubmFtZSkuam9pbignLCAnKX1gLmN5YW59YCk7XG5cbiAgY29uc3QgcGFja2FnZUpTT04gPSBhd2FpdCByZWFkTXV0YXRlZFBhY2thZ2VKc29uKGRpciwgZm9yZ2VDb25maWcpO1xuICBjb25zdCBhcHBOYW1lID0gZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcubmFtZSB8fCBwYWNrYWdlSlNPTi5wcm9kdWN0TmFtZSB8fCBwYWNrYWdlSlNPTi5uYW1lO1xuICBjb25zdCBvdXRwdXRzOiBGb3JnZU1ha2VSZXN1bHRbXSA9IFtdO1xuXG4gIGF3YWl0IHJ1bkhvb2soZm9yZ2VDb25maWcsICdwcmVNYWtlJyk7XG5cbiAgZm9yIChjb25zdCB0YXJnZXRBcmNoIG9mIHBhcnNlQXJjaHMocGxhdGZvcm0sIGFyY2gsIGF3YWl0IGdldEVsZWN0cm9uVmVyc2lvbihkaXIsIHBhY2thZ2VKU09OKSkpIHtcbiAgICBjb25zdCBwYWNrYWdlRGlyID0gcGF0aC5yZXNvbHZlKGFjdHVhbE91dERpciwgYCR7YXBwTmFtZX0tJHthY3R1YWxUYXJnZXRQbGF0Zm9ybX0tJHt0YXJnZXRBcmNofWApO1xuICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMocGFja2FnZURpcikpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgcGFja2FnZWQgYXBwIGF0OiAke3BhY2thZ2VEaXJ9YCk7XG4gICAgfVxuXG4gICAgdGFyZ2V0SWQgPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZm9yIChjb25zdCBfdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgIGNvbnN0IG1ha2VyID0gbWFrZXJzW3RhcmdldElkXTtcbiAgICAgIHRhcmdldElkICs9IDE7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIGF3YWl0IGFzeW5jT3JhKGBNYWtpbmcgZm9yIHRhcmdldDogJHttYWtlci5uYW1lLmdyZWVufSAtIE9uIHBsYXRmb3JtOiAke2FjdHVhbFRhcmdldFBsYXRmb3JtLmN5YW59IC0gRm9yIGFyY2g6ICR7dGFyZ2V0QXJjaC5jeWFufWAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXQVJOSU5HOiBETyBOT1QgQVRURU1QVCBUTyBQQVJBTExFTElaRSBNQUtFUlNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEN1cnJlbnRseSBpdCBpcyBhc3N1bWVkIHdlIGhhdmUgMSBtYWtlciBwZXIgbWFrZSBjYWxsIGJ1dCB0aGF0IGlzXG4gICAgICAgICAgICogbm90IGVuZm9yY2VkLiAgSXQgaXMgdGVjaG5pY2FsbHkgcG9zc2libGUgdG8gaGF2ZSAxIG1ha2VyIGJlIGNhbGxlZFxuICAgICAgICAgICAqIG11bHRpcGxlIHRpbWVzLiAgVGhlIFwicHJlcGFyZUNvbmZpZ1wiIG1ldGhvZCBob3dldmVyIGltcGxpY2l0bHlcbiAgICAgICAgICAgKiByZXF1aXJlcyBhIGxvY2sgdGhhdCBpcyBub3QgZW5mb3JjZWQuICBUaGVyZSBhcmUgdHdvIG9wdGlvbnM6XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgICogUHJvdmlkZSBtYWtlcnMgYSBnZXRDb25maWcoKSBtZXRob2RcbiAgICAgICAgICAgKiAgICogUmVtb3ZlIHN1cHBvcnQgZm9yIGNvbmZpZyBiZWluZyBwcm92aWRlZCBhcyBhIG1ldGhvZFxuICAgICAgICAgICAqICAgKiBDaGFuZ2UgdGhlIGVudGlyZSBBUEkgb2YgbWFrZXIgZnJvbSBhIHNpbmdsZSBjb25zdHJ1Y3RvciB0b1xuICAgICAgICAgICAqICAgICBwcm92aWRpbmcgYSBNYWtlckZhY3RvcnlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBtYWtlci5wcmVwYXJlQ29uZmlnKHRhcmdldEFyY2gpO1xuICAgICAgICAgIGNvbnN0IGFydGlmYWN0cyA9IGF3YWl0IG1ha2VyLm1ha2Uoe1xuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIGZvcmdlQ29uZmlnLFxuICAgICAgICAgICAgcGFja2FnZUpTT04sXG4gICAgICAgICAgICB0YXJnZXRBcmNoLFxuICAgICAgICAgICAgZGlyOiBwYWNrYWdlRGlyLFxuICAgICAgICAgICAgbWFrZURpcjogcGF0aC5yZXNvbHZlKGFjdHVhbE91dERpciwgJ21ha2UnKSxcbiAgICAgICAgICAgIHRhcmdldFBsYXRmb3JtOiBhY3R1YWxUYXJnZXRQbGF0Zm9ybSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICBhcnRpZmFjdHMsXG4gICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgIHBsYXRmb3JtOiBhY3R1YWxUYXJnZXRQbGF0Zm9ybSxcbiAgICAgICAgICAgIGFyY2g6IHRhcmdldEFyY2gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7bWFrZXIubmFtZX1gLFxuICAgICAgICAgICAgICBzdGFjazogYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiB1bmtub3duIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7bWFrZXIubmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBwb3N0TWFrZSBob29rcyBtb2RpZmllcyB0aGUgbG9jYXRpb25zIC8gbmFtZXMgb2YgdGhlIG91dHB1dHMgaXQgbXVzdCByZXR1cm5cbiAgLy8gdGhlIG5ldyBsb2NhdGlvbnMgc28gdGhhdCB0aGUgcHVibGlzaCBzdGVwIGtub3dzIHdoZXJlIHRvIGxvb2tcbiAgcmV0dXJuIHJ1bk11dGF0aW5nSG9vayhmb3JnZUNvbmZpZywgJ3Bvc3RNYWtlJywgb3V0cHV0cyk7XG59O1xuIl19