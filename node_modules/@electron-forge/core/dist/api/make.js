"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _asyncOra = require("@electron-forge/async-ora");

var _chalk = _interopRequireDefault(require("chalk"));

var _get = require("@electron/get");

var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));

var _hook = require("../util/hook");

var _messages = require("../util/messages");

var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));

var _readPackageJson = require("../util/read-package-json");

var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));

var _outDir = _interopRequireDefault(require("../util/out-dir"));

var _electronVersion = require("../util/electron-version");

var _requireSearch = _interopRequireDefault(require("../util/require-search"));

var _package = _interopRequireDefault(require("./package"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MakerImpl extends _makerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'impl');

    _defineProperty(this, "defaultPlatforms", []);
  }

} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function generateTargets(forgeConfig, overrideTargets) {
  if (overrideTargets) {
    return overrideTargets.map(target => {
      if (typeof target === 'string') {
        return forgeConfig.makers.find(maker => maker.name === target) || {
          name: target
        };
      }

      return target;
    });
  }

  return forgeConfig.makers;
}

var _default = async ({
  dir = process.cwd(),
  interactive = false,
  skipPackage = false,
  arch = (0, _get.getHostArch)(),
  platform = process.platform,
  overrideTargets,
  outDir
}) => {
  _asyncOra.asyncOra.interactive = interactive;
  let forgeConfig;
  await (0, _asyncOra.asyncOra)('Resolving Forge Config', async () => {
    const resolvedDir = await (0, _resolveDir.default)(dir);

    if (!resolvedDir) {
      throw new Error('Failed to locate makeable Electron application');
    }

    dir = resolvedDir;
    forgeConfig = await (0, _forgeConfig.default)(dir);
  });
  const actualOutDir = outDir || (0, _outDir.default)(dir, forgeConfig);
  const actualTargetPlatform = platform;
  platform = platform === 'mas' ? 'darwin' : platform;

  if (!['darwin', 'win32', 'linux', 'mas'].includes(actualTargetPlatform)) {
    throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'`);
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  const makers = {};
  let targets = generateTargets(forgeConfig, overrideTargets);
  let targetId = 0;

  for (const target of targets) {
    /* eslint-disable @typescript-eslint/no-explicit-any */
    let maker; // eslint-disable-next-line no-underscore-dangle

    if (target.__isElectronForgeMaker) {
      maker = target;
      /* eslint-enable @typescript-eslint/no-explicit-any */
      // eslint-disable-next-line no-continue

      if (!maker.platforms.includes(actualTargetPlatform)) continue;
    } else {
      const resolvableTarget = target;

      if (!resolvableTarget.name) {
        throw new Error(`The following maker config is missing a maker name: ${JSON.stringify(resolvableTarget)}`);
      } else if (typeof resolvableTarget.name !== 'string') {
        throw new Error(`The following maker config has a maker name that is not a string: ${JSON.stringify(resolvableTarget)}`);
      }

      const MakerClass = (0, _requireSearch.default)(dir, [resolvableTarget.name]);

      if (!MakerClass) {
        throw new Error(`Could not find module with name: ${resolvableTarget.name}. Make sure it's listed in the devDependencies of your package.json`);
      }

      maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined); // eslint-disable-next-line no-continue

      if (!maker.platforms.includes(actualTargetPlatform)) continue;
    }

    if (!maker.isSupportedOnCurrentPlatform) {
      throw new Error([`Maker for target ${maker.name} is incompatible with this version of `, 'electron-forge, please upgrade or contact the maintainer ', "(needs to implement 'isSupportedOnCurrentPlatform)')"].join(''));
    }

    if (!maker.isSupportedOnCurrentPlatform()) {
      throw new Error([`Cannot make for ${platform} and target ${maker.name}: the maker declared `, `that it cannot run on ${process.platform}`].join(''));
    }

    maker.ensureExternalBinariesExist();
    makers[targetId] = maker;
    targetId += 1;
  }

  if (!skipPackage) {
    (0, _messages.info)(interactive, _chalk.default.green('We need to package your application before we can make it'));
    await (0, _package.default)({
      dir,
      interactive,
      arch,
      outDir: actualOutDir,
      platform: actualTargetPlatform
    });
  } else {
    (0, _messages.warn)(interactive, _chalk.default.red('WARNING: Skipping the packaging step, this could result in an out of date build'));
  }

  targets = targets.filter((_, i) => makers[i]);

  if (targets.length === 0) {
    throw new Error(`Could not find any make targets configured for the "${actualTargetPlatform}" platform.`);
  }

  (0, _messages.info)(interactive, `Making for the following targets: ${_chalk.default.cyan(`${targets.map((_t, i) => makers[i].name).join(', ')}`)}`);
  const packageJSON = await (0, _readPackageJson.readMutatedPackageJson)(dir, forgeConfig);
  const appName = forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name;
  const outputs = [];
  await (0, _hook.runHook)(forgeConfig, 'preMake');

  for (const targetArch of (0, _parseArchs.default)(platform, arch, await (0, _electronVersion.getElectronVersion)(dir, packageJSON))) {
    const packageDir = _path.default.resolve(actualOutDir, `${appName}-${actualTargetPlatform}-${targetArch}`);

    if (!(await _fsExtra.default.pathExists(packageDir))) {
      throw new Error(`Couldn't find packaged app at: ${packageDir}`);
    }

    targetId = 0; // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-unused-vars

    for (const _target of targets) {
      const maker = makers[targetId];
      targetId += 1; // eslint-disable-next-line no-loop-func

      await (0, _asyncOra.asyncOra)(`Making for target: ${_chalk.default.green(maker.name)} - On platform: ${_chalk.default.cyan(actualTargetPlatform)} - For arch: ${_chalk.default.cyan(targetArch)}`, async () => {
        try {
          /**
           * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
           *
           * Currently it is assumed we have 1 maker per make call but that is
           * not enforced.  It is technically possible to have 1 maker be called
           * multiple times.  The "prepareConfig" method however implicitly
           * requires a lock that is not enforced.  There are two options:
           *
           *   * Provide makers a getConfig() method
           *   * Remove support for config being provided as a method
           *   * Change the entire API of maker from a single constructor to
           *     providing a MakerFactory
           */
          maker.prepareConfig(targetArch);
          const artifacts = await maker.make({
            appName,
            forgeConfig,
            packageJSON,
            targetArch,
            dir: packageDir,
            makeDir: _path.default.resolve(actualOutDir, 'make'),
            targetPlatform: actualTargetPlatform
          });
          outputs.push({
            artifacts,
            packageJSON,
            platform: actualTargetPlatform,
            arch: targetArch
          });
        } catch (err) {
          if (err instanceof Error) {
            // eslint-disable-next-line no-throw-literal
            throw {
              message: `An error occured while making for target: ${maker.name}`,
              stack: `${err.message}\n${err.stack}`
            };
          } else if (err) {
            throw err;
          } else {
            throw new Error(`An unknown error occured while making for target: ${maker.name}`);
          }
        }
      });
    }
  } // If the postMake hooks modifies the locations / names of the outputs it must return
  // the new locations so that the publish step knows where to look


  return (0, _hook.runMutatingHook)(forgeConfig, 'postMake', outputs);
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJuYW1lcyI6WyJNYWtlckltcGwiLCJNYWtlckJhc2UiLCJnZW5lcmF0ZVRhcmdldHMiLCJmb3JnZUNvbmZpZyIsIm92ZXJyaWRlVGFyZ2V0cyIsIm1hcCIsInRhcmdldCIsIm1ha2VycyIsImZpbmQiLCJtYWtlciIsIm5hbWUiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJza2lwUGFja2FnZSIsImFyY2giLCJwbGF0Zm9ybSIsIm91dERpciIsImFzeW5jT3JhIiwicmVzb2x2ZWREaXIiLCJFcnJvciIsImFjdHVhbE91dERpciIsImFjdHVhbFRhcmdldFBsYXRmb3JtIiwiaW5jbHVkZXMiLCJ0YXJnZXRzIiwidGFyZ2V0SWQiLCJfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyIiwicGxhdGZvcm1zIiwicmVzb2x2YWJsZVRhcmdldCIsIkpTT04iLCJzdHJpbmdpZnkiLCJNYWtlckNsYXNzIiwiY29uZmlnIiwidW5kZWZpbmVkIiwiaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSIsImpvaW4iLCJlbnN1cmVFeHRlcm5hbEJpbmFyaWVzRXhpc3QiLCJjaGFsayIsImdyZWVuIiwicmVkIiwiZmlsdGVyIiwiXyIsImkiLCJsZW5ndGgiLCJjeWFuIiwiX3QiLCJwYWNrYWdlSlNPTiIsImFwcE5hbWUiLCJwYWNrYWdlckNvbmZpZyIsInByb2R1Y3ROYW1lIiwib3V0cHV0cyIsInRhcmdldEFyY2giLCJwYWNrYWdlRGlyIiwicGF0aCIsInJlc29sdmUiLCJmcyIsInBhdGhFeGlzdHMiLCJfdGFyZ2V0IiwicHJlcGFyZUNvbmZpZyIsImFydGlmYWN0cyIsIm1ha2UiLCJtYWtlRGlyIiwidGFyZ2V0UGxhdGZvcm0iLCJwdXNoIiwiZXJyIiwibWVzc2FnZSIsInN0YWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7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LFdBQWhCLEVBQTZCLFVBQTdCLEVBQXlDZ0QsT0FBekMsQ0FBUDtBQUNELEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3luY09yYSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9hc3luYy1vcmEnO1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IGdldEhvc3RBcmNoIH0gZnJvbSAnQGVsZWN0cm9uL2dldCc7XG5pbXBvcnQgeyBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIsIEZvcmdlQ29uZmlnLCBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0sIEZvcmdlTWFrZVJlc3VsdCB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IE1ha2VyQmFzZSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvbWFrZXItYmFzZSc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCBnZXRGb3JnZUNvbmZpZyBmcm9tICcuLi91dGlsL2ZvcmdlLWNvbmZpZyc7XG5pbXBvcnQgeyBydW5Ib29rLCBydW5NdXRhdGluZ0hvb2sgfSBmcm9tICcuLi91dGlsL2hvb2snO1xuaW1wb3J0IHsgaW5mbywgd2FybiB9IGZyb20gJy4uL3V0aWwvbWVzc2FnZXMnO1xuaW1wb3J0IHBhcnNlQXJjaHMgZnJvbSAnLi4vdXRpbC9wYXJzZS1hcmNocyc7XG5pbXBvcnQgeyByZWFkTXV0YXRlZFBhY2thZ2VKc29uIH0gZnJvbSAnLi4vdXRpbC9yZWFkLXBhY2thZ2UtanNvbic7XG5pbXBvcnQgcmVzb2x2ZURpciBmcm9tICcuLi91dGlsL3Jlc29sdmUtZGlyJztcbmltcG9ydCBnZXRDdXJyZW50T3V0RGlyIGZyb20gJy4uL3V0aWwvb3V0LWRpcic7XG5pbXBvcnQgeyBnZXRFbGVjdHJvblZlcnNpb24gfSBmcm9tICcuLi91dGlsL2VsZWN0cm9uLXZlcnNpb24nO1xuaW1wb3J0IHJlcXVpcmVTZWFyY2ggZnJvbSAnLi4vdXRpbC9yZXF1aXJlLXNlYXJjaCc7XG5cbmltcG9ydCBwYWNrYWdlciBmcm9tICcuL3BhY2thZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY2xhc3MgTWFrZXJJbXBsIGV4dGVuZHMgTWFrZXJCYXNlPGFueT4ge1xuICBuYW1lID0gJ2ltcGwnO1xuXG4gIGRlZmF1bHRQbGF0Zm9ybXMgPSBbXTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnR5cGUgTWFrZVRhcmdldCA9IElGb3JnZVJlc29sdmFibGVNYWtlciB8IE1ha2VyQmFzZTxhbnk+IHwgc3RyaW5nO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRhcmdldHMoZm9yZ2VDb25maWc6IEZvcmdlQ29uZmlnLCBvdmVycmlkZVRhcmdldHM/OiBNYWtlVGFyZ2V0W10pIHtcbiAgaWYgKG92ZXJyaWRlVGFyZ2V0cykge1xuICAgIHJldHVybiBvdmVycmlkZVRhcmdldHMubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZm9yZ2VDb25maWcubWFrZXJzLmZpbmQoKG1ha2VyKSA9PiAobWFrZXIgYXMgSUZvcmdlUmVzb2x2YWJsZU1ha2VyKS5uYW1lID09PSB0YXJnZXQpIHx8IHsgbmFtZTogdGFyZ2V0IH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZvcmdlQ29uZmlnLm1ha2Vycztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYWtlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgYXBwIGZyb20gd2hpY2ggZGlzdHJ1YnV0YWJsZXMgYXJlIGdlbmVyYXRlZFxuICAgKi9cbiAgZGlyPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0byB1c2Ugc2Vuc2libGUgZGVmYXVsdHMgb3IgcHJvbXB0IHRoZSB1c2VyIHZpc3VhbGx5XG4gICAqL1xuICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHNraXAgdGhlIHByZS1tYWtlIHBhY2thZ2luZyBzdGVwXG4gICAqL1xuICBza2lwUGFja2FnZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBtYWtlIHRhcmdldHMgdG8gb3ZlcnJpZGUgeW91ciBmb3JnZSBjb25maWdcbiAgICovXG4gIG92ZXJyaWRlVGFyZ2V0cz86IE1ha2VUYXJnZXRbXTtcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgYXJjaGl0ZWN0dXJlXG4gICAqL1xuICBhcmNoPzogRm9yZ2VBcmNoO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBwbGF0Zm9ybVxuICAgKi9cbiAgcGxhdGZvcm0/OiBGb3JnZVBsYXRmb3JtO1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIGRpcmVjdG9yeSBjb250YWluaW5nIGdlbmVyYXRlZCBkaXN0cmlidXRhYmxlc1xuICAgKi9cbiAgb3V0RGlyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoe1xuICBkaXIgPSBwcm9jZXNzLmN3ZCgpLFxuICBpbnRlcmFjdGl2ZSA9IGZhbHNlLFxuICBza2lwUGFja2FnZSA9IGZhbHNlLFxuICBhcmNoID0gZ2V0SG9zdEFyY2goKSBhcyBGb3JnZUFyY2gsXG4gIHBsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybSBhcyBGb3JnZVBsYXRmb3JtLFxuICBvdmVycmlkZVRhcmdldHMsXG4gIG91dERpcixcbn06IE1ha2VPcHRpb25zKTogUHJvbWlzZTxGb3JnZU1ha2VSZXN1bHRbXT4gPT4ge1xuICBhc3luY09yYS5pbnRlcmFjdGl2ZSA9IGludGVyYWN0aXZlO1xuXG4gIGxldCBmb3JnZUNvbmZpZyE6IEZvcmdlQ29uZmlnO1xuICBhd2FpdCBhc3luY09yYSgnUmVzb2x2aW5nIEZvcmdlIENvbmZpZycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZERpciA9IGF3YWl0IHJlc29sdmVEaXIoZGlyKTtcbiAgICBpZiAoIXJlc29sdmVkRGlyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2NhdGUgbWFrZWFibGUgRWxlY3Ryb24gYXBwbGljYXRpb24nKTtcbiAgICB9XG4gICAgZGlyID0gcmVzb2x2ZWREaXI7XG5cbiAgICBmb3JnZUNvbmZpZyA9IGF3YWl0IGdldEZvcmdlQ29uZmlnKGRpcik7XG4gIH0pO1xuXG4gIGNvbnN0IGFjdHVhbE91dERpciA9IG91dERpciB8fCBnZXRDdXJyZW50T3V0RGlyKGRpciwgZm9yZ2VDb25maWcpO1xuXG4gIGNvbnN0IGFjdHVhbFRhcmdldFBsYXRmb3JtID0gcGxhdGZvcm07XG4gIHBsYXRmb3JtID0gcGxhdGZvcm0gPT09ICdtYXMnID8gJ2RhcndpbicgOiBwbGF0Zm9ybTtcbiAgaWYgKCFbJ2RhcndpbicsICd3aW4zMicsICdsaW51eCcsICdtYXMnXS5pbmNsdWRlcyhhY3R1YWxUYXJnZXRQbGF0Zm9ybSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2FjdHVhbFRhcmdldFBsYXRmb3JtfScgaXMgYW4gaW52YWxpZCBwbGF0Zm9ybS4gQ2hvaWNlcyBhcmUgJ2RhcndpbicsICdtYXMnLCAnd2luMzInIG9yICdsaW51eCdgKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IG1ha2VyczogUmVjb3JkPG51bWJlciwgTWFrZXJCYXNlPGFueT4+ID0ge307XG5cbiAgbGV0IHRhcmdldHMgPSBnZW5lcmF0ZVRhcmdldHMoZm9yZ2VDb25maWcsIG92ZXJyaWRlVGFyZ2V0cyk7XG5cbiAgbGV0IHRhcmdldElkID0gMDtcbiAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbiAgICBsZXQgbWFrZXI6IE1ha2VyQmFzZTxhbnk+O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIGlmICgodGFyZ2V0IGFzIE1ha2VyQmFzZTxhbnk+KS5fX2lzRWxlY3Ryb25Gb3JnZU1ha2VyKSB7XG4gICAgICBtYWtlciA9IHRhcmdldCBhcyBNYWtlckJhc2U8YW55PjtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBpZiAoIW1ha2VyLnBsYXRmb3Jtcy5pbmNsdWRlcyhhY3R1YWxUYXJnZXRQbGF0Zm9ybSkpIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNvbHZhYmxlVGFyZ2V0OiBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIgPSB0YXJnZXQgYXMgSUZvcmdlUmVzb2x2YWJsZU1ha2VyO1xuXG4gICAgICBpZiAoIXJlc29sdmFibGVUYXJnZXQubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgbWFrZXIgY29uZmlnIGlzIG1pc3NpbmcgYSBtYWtlciBuYW1lOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdmFibGVUYXJnZXQpfWApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzb2x2YWJsZVRhcmdldC5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgbWFrZXIgY29uZmlnIGhhcyBhIG1ha2VyIG5hbWUgdGhhdCBpcyBub3QgYSBzdHJpbmc6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2YWJsZVRhcmdldCl9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IE1ha2VyQ2xhc3MgPSByZXF1aXJlU2VhcmNoPHR5cGVvZiBNYWtlckltcGw+KGRpciwgW3Jlc29sdmFibGVUYXJnZXQubmFtZV0pO1xuICAgICAgaWYgKCFNYWtlckNsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgbW9kdWxlIHdpdGggbmFtZTogJHtyZXNvbHZhYmxlVGFyZ2V0Lm5hbWV9LiBNYWtlIHN1cmUgaXQncyBsaXN0ZWQgaW4gdGhlIGRldkRlcGVuZGVuY2llcyBvZiB5b3VyIHBhY2thZ2UuanNvbmApO1xuICAgICAgfVxuXG4gICAgICBtYWtlciA9IG5ldyBNYWtlckNsYXNzKHJlc29sdmFibGVUYXJnZXQuY29uZmlnLCByZXNvbHZhYmxlVGFyZ2V0LnBsYXRmb3JtcyB8fCB1bmRlZmluZWQpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBpZiAoIW1ha2VyLnBsYXRmb3Jtcy5pbmNsdWRlcyhhY3R1YWxUYXJnZXRQbGF0Zm9ybSkpIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghbWFrZXIuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBbXG4gICAgICAgICAgYE1ha2VyIGZvciB0YXJnZXQgJHttYWtlci5uYW1lfSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGlzIHZlcnNpb24gb2YgYCxcbiAgICAgICAgICAnZWxlY3Ryb24tZm9yZ2UsIHBsZWFzZSB1cGdyYWRlIG9yIGNvbnRhY3QgdGhlIG1haW50YWluZXIgJyxcbiAgICAgICAgICBcIihuZWVkcyB0byBpbXBsZW1lbnQgJ2lzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pJylcIixcbiAgICAgICAgXS5qb2luKCcnKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIW1ha2VyLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtgQ2Fubm90IG1ha2UgZm9yICR7cGxhdGZvcm19IGFuZCB0YXJnZXQgJHttYWtlci5uYW1lfTogdGhlIG1ha2VyIGRlY2xhcmVkIGAsIGB0aGF0IGl0IGNhbm5vdCBydW4gb24gJHtwcm9jZXNzLnBsYXRmb3JtfWBdLmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICBtYWtlci5lbnN1cmVFeHRlcm5hbEJpbmFyaWVzRXhpc3QoKTtcblxuICAgIG1ha2Vyc1t0YXJnZXRJZF0gPSBtYWtlcjtcbiAgICB0YXJnZXRJZCArPSAxO1xuICB9XG5cbiAgaWYgKCFza2lwUGFja2FnZSkge1xuICAgIGluZm8oaW50ZXJhY3RpdmUsIGNoYWxrLmdyZWVuKCdXZSBuZWVkIHRvIHBhY2thZ2UgeW91ciBhcHBsaWNhdGlvbiBiZWZvcmUgd2UgY2FuIG1ha2UgaXQnKSk7XG4gICAgYXdhaXQgcGFja2FnZXIoe1xuICAgICAgZGlyLFxuICAgICAgaW50ZXJhY3RpdmUsXG4gICAgICBhcmNoLFxuICAgICAgb3V0RGlyOiBhY3R1YWxPdXREaXIsXG4gICAgICBwbGF0Zm9ybTogYWN0dWFsVGFyZ2V0UGxhdGZvcm0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybihpbnRlcmFjdGl2ZSwgY2hhbGsucmVkKCdXQVJOSU5HOiBTa2lwcGluZyB0aGUgcGFja2FnaW5nIHN0ZXAsIHRoaXMgY291bGQgcmVzdWx0IGluIGFuIG91dCBvZiBkYXRlIGJ1aWxkJykpO1xuICB9XG5cbiAgdGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKChfLCBpKSA9PiBtYWtlcnNbaV0pO1xuXG4gIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IG1ha2UgdGFyZ2V0cyBjb25maWd1cmVkIGZvciB0aGUgXCIke2FjdHVhbFRhcmdldFBsYXRmb3JtfVwiIHBsYXRmb3JtLmApO1xuICB9XG5cbiAgaW5mbyhpbnRlcmFjdGl2ZSwgYE1ha2luZyBmb3IgdGhlIGZvbGxvd2luZyB0YXJnZXRzOiAke2NoYWxrLmN5YW4oYCR7dGFyZ2V0cy5tYXAoKF90LCBpKSA9PiBtYWtlcnNbaV0ubmFtZSkuam9pbignLCAnKX1gKX1gKTtcblxuICBjb25zdCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRNdXRhdGVkUGFja2FnZUpzb24oZGlyLCBmb3JnZUNvbmZpZyk7XG4gIGNvbnN0IGFwcE5hbWUgPSBmb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZy5uYW1lIHx8IHBhY2thZ2VKU09OLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VKU09OLm5hbWU7XG4gIGNvbnN0IG91dHB1dHM6IEZvcmdlTWFrZVJlc3VsdFtdID0gW107XG5cbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3ByZU1ha2UnKTtcblxuICBmb3IgKGNvbnN0IHRhcmdldEFyY2ggb2YgcGFyc2VBcmNocyhwbGF0Zm9ybSwgYXJjaCwgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pKSkge1xuICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCBgJHthcHBOYW1lfS0ke2FjdHVhbFRhcmdldFBsYXRmb3JtfS0ke3RhcmdldEFyY2h9YCk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYWNrYWdlRGlyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICB9XG5cbiAgICB0YXJnZXRJZCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IF90YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgY29uc3QgbWFrZXIgPSBtYWtlcnNbdGFyZ2V0SWRdO1xuICAgICAgdGFyZ2V0SWQgKz0gMTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgYXdhaXQgYXN5bmNPcmEoXG4gICAgICAgIGBNYWtpbmcgZm9yIHRhcmdldDogJHtjaGFsay5ncmVlbihtYWtlci5uYW1lKX0gLSBPbiBwbGF0Zm9ybTogJHtjaGFsay5jeWFuKGFjdHVhbFRhcmdldFBsYXRmb3JtKX0gLSBGb3IgYXJjaDogJHtjaGFsay5jeWFuKHRhcmdldEFyY2gpfWAsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXQVJOSU5HOiBETyBOT1QgQVRURU1QVCBUTyBQQVJBTExFTElaRSBNQUtFUlNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBDdXJyZW50bHkgaXQgaXMgYXNzdW1lZCB3ZSBoYXZlIDEgbWFrZXIgcGVyIG1ha2UgY2FsbCBidXQgdGhhdCBpc1xuICAgICAgICAgICAgICogbm90IGVuZm9yY2VkLiAgSXQgaXMgdGVjaG5pY2FsbHkgcG9zc2libGUgdG8gaGF2ZSAxIG1ha2VyIGJlIGNhbGxlZFxuICAgICAgICAgICAgICogbXVsdGlwbGUgdGltZXMuICBUaGUgXCJwcmVwYXJlQ29uZmlnXCIgbWV0aG9kIGhvd2V2ZXIgaW1wbGljaXRseVxuICAgICAgICAgICAgICogcmVxdWlyZXMgYSBsb2NrIHRoYXQgaXMgbm90IGVuZm9yY2VkLiAgVGhlcmUgYXJlIHR3byBvcHRpb25zOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgKiBQcm92aWRlIG1ha2VycyBhIGdldENvbmZpZygpIG1ldGhvZFxuICAgICAgICAgICAgICogICAqIFJlbW92ZSBzdXBwb3J0IGZvciBjb25maWcgYmVpbmcgcHJvdmlkZWQgYXMgYSBtZXRob2RcbiAgICAgICAgICAgICAqICAgKiBDaGFuZ2UgdGhlIGVudGlyZSBBUEkgb2YgbWFrZXIgZnJvbSBhIHNpbmdsZSBjb25zdHJ1Y3RvciB0b1xuICAgICAgICAgICAgICogICAgIHByb3ZpZGluZyBhIE1ha2VyRmFjdG9yeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYWtlci5wcmVwYXJlQ29uZmlnKHRhcmdldEFyY2gpO1xuICAgICAgICAgICAgY29uc3QgYXJ0aWZhY3RzID0gYXdhaXQgbWFrZXIubWFrZSh7XG4gICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgIGZvcmdlQ29uZmlnLFxuICAgICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgICAgdGFyZ2V0QXJjaCxcbiAgICAgICAgICAgICAgZGlyOiBwYWNrYWdlRGlyLFxuICAgICAgICAgICAgICBtYWtlRGlyOiBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCAnbWFrZScpLFxuICAgICAgICAgICAgICB0YXJnZXRQbGF0Zm9ybTogYWN0dWFsVGFyZ2V0UGxhdGZvcm0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgYXJ0aWZhY3RzLFxuICAgICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgICAgcGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgICAgICBhcmNoOiB0YXJnZXRBcmNoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBBbiBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCxcbiAgICAgICAgICAgICAgICBzdGFjazogYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gdW5rbm93biBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBwb3N0TWFrZSBob29rcyBtb2RpZmllcyB0aGUgbG9jYXRpb25zIC8gbmFtZXMgb2YgdGhlIG91dHB1dHMgaXQgbXVzdCByZXR1cm5cbiAgLy8gdGhlIG5ldyBsb2NhdGlvbnMgc28gdGhhdCB0aGUgcHVibGlzaCBzdGVwIGtub3dzIHdoZXJlIHRvIGxvb2tcbiAgcmV0dXJuIHJ1bk11dGF0aW5nSG9vayhmb3JnZUNvbmZpZywgJ3Bvc3RNYWtlJywgb3V0cHV0cyk7XG59O1xuIl19