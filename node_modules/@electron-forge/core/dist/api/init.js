"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _asyncOra = require("@electron-forge/async-ora");

var _debug = _interopRequireDefault(require("debug"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _semver = _interopRequireDefault(require("semver"));

var _findTemplate = _interopRequireDefault(require("./init-scripts/find-template"));

var _initDirectory = _interopRequireDefault(require("./init-scripts/init-directory"));

var _initGit = _interopRequireDefault(require("./init-scripts/init-git"));

var _initNpm = _interopRequireDefault(require("./init-scripts/init-npm"));

var _installDependencies = _interopRequireWildcard(require("../util/install-dependencies"));

var _readPackageJson = require("../util/read-package-json");

var _forgeConfig = require("../util/forge-config");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:init');

async function validateTemplate(template, templateModule) {
  if (!templateModule.requiredForgeVersion) {
    throw new Error(`Cannot use a template (${template}) with this version of Electron Forge, as it does not specify its required Forge version.`);
  }

  const forgeVersion = (await (0, _readPackageJson.readRawPackageJson)(_path.default.join(__dirname, '..', '..'))).version;

  if (!_semver.default.satisfies(forgeVersion, templateModule.requiredForgeVersion)) {
    throw new Error(`Template (${template}) is not compatible with this version of Electron Forge (${forgeVersion}), it requires ${templateModule.requiredForgeVersion}`);
  }
}

var _default = async ({
  dir = process.cwd(),
  interactive = false,
  copyCIFiles = false,
  force = false,
  template = 'base'
}) => {
  _asyncOra.asyncOra.interactive = interactive;
  d(`Initializing in: ${dir}`);
  await (0, _initDirectory.default)(dir, force);
  await (0, _initGit.default)(dir);
  const templateModule = await (0, _findTemplate.default)(dir, template);
  await validateTemplate(template, templateModule);

  if (typeof templateModule.initializeTemplate === 'function') {
    await templateModule.initializeTemplate(dir, {
      copyCIFiles
    });
    const packageJSON = await (0, _readPackageJson.readRawPackageJson)(dir);
    (0, _forgeConfig.setInitialForgeConfig)(packageJSON);
    await _fsExtra.default.writeJson(_path.default.join(dir, 'package.json'), packageJSON, {
      spaces: 2
    });
  }

  await (0, _asyncOra.asyncOra)('Installing Template Dependencies', async () => {
    d('installing dependencies');
    await (0, _installDependencies.default)(dir, templateModule.dependencies || []);
    d('installing devDependencies');
    await (0, _installDependencies.default)(dir, templateModule.devDependencies || [], _installDependencies.DepType.DEV);
  });
  await (0, _initNpm.default)(dir);
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvaW5pdC50cyJdLCJuYW1lcyI6WyJkIiwidmFsaWRhdGVUZW1wbGF0ZSIsInRlbXBsYXRlIiwidGVtcGxhdGVNb2R1bGUiLCJyZXF1aXJlZEZvcmdlVmVyc2lvbiIsIkVycm9yIiwiZm9yZ2VWZXJzaW9uIiwicGF0aCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJ2ZXJzaW9uIiwic2VtdmVyIiwic2F0aXNmaWVzIiwiZGlyIiwicHJvY2VzcyIsImN3ZCIsImludGVyYWN0aXZlIiwiY29weUNJRmlsZXMiLCJmb3JjZSIsImFzeW5jT3JhIiwiaW5pdGlhbGl6ZVRlbXBsYXRlIiwicGFja2FnZUpTT04iLCJmcyIsIndyaXRlSnNvbiIsInNwYWNlcyIsImRlcGVuZGVuY2llcyIsImRldkRlcGVuZGVuY2llcyIsIkRlcFR5cGUiLCJERVYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLE1BQU1BLENBQUMsR0FBRyxvQkFBTSxxQkFBTixDQUFWOztBQXlCQSxlQUFlQyxnQkFBZixDQUFnQ0MsUUFBaEMsRUFBa0RDLGNBQWxELEVBQWdHO0FBQzlGLE1BQUksQ0FBQ0EsY0FBYyxDQUFDQyxvQkFBcEIsRUFBMEM7QUFDeEMsVUFBTSxJQUFJQyxLQUFKLENBQVcsMEJBQXlCSCxRQUFTLDJGQUE3QyxDQUFOO0FBQ0Q7O0FBRUQsUUFBTUksWUFBWSxHQUFHLENBQUMsTUFBTSx5Q0FBbUJDLGNBQUtDLElBQUwsQ0FBVUMsU0FBVixFQUFxQixJQUFyQixFQUEyQixJQUEzQixDQUFuQixDQUFQLEVBQTZEQyxPQUFsRjs7QUFDQSxNQUFJLENBQUNDLGdCQUFPQyxTQUFQLENBQWlCTixZQUFqQixFQUErQkgsY0FBYyxDQUFDQyxvQkFBOUMsQ0FBTCxFQUEwRTtBQUN4RSxVQUFNLElBQUlDLEtBQUosQ0FDSCxhQUFZSCxRQUFTLDREQUEyREksWUFBYSxrQkFBaUJILGNBQWMsQ0FBQ0Msb0JBQXFCLEVBRC9JLENBQU47QUFHRDtBQUNGOztlQUVjLE9BQU87QUFBRVMsRUFBQUEsR0FBRyxHQUFHQyxPQUFPLENBQUNDLEdBQVIsRUFBUjtBQUF1QkMsRUFBQUEsV0FBVyxHQUFHLEtBQXJDO0FBQTRDQyxFQUFBQSxXQUFXLEdBQUcsS0FBMUQ7QUFBaUVDLEVBQUFBLEtBQUssR0FBRyxLQUF6RTtBQUFnRmhCLEVBQUFBLFFBQVEsR0FBRztBQUEzRixDQUFQLEtBQTJJO0FBQ3hKaUIscUJBQVNILFdBQVQsR0FBdUJBLFdBQXZCO0FBRUFoQixFQUFBQSxDQUFDLENBQUUsb0JBQW1CYSxHQUFJLEVBQXpCLENBQUQ7QUFFQSxRQUFNLDRCQUFjQSxHQUFkLEVBQW1CSyxLQUFuQixDQUFOO0FBQ0EsUUFBTSxzQkFBUUwsR0FBUixDQUFOO0FBQ0EsUUFBTVYsY0FBYyxHQUFHLE1BQU0sMkJBQWFVLEdBQWIsRUFBa0JYLFFBQWxCLENBQTdCO0FBRUEsUUFBTUQsZ0JBQWdCLENBQUNDLFFBQUQsRUFBV0MsY0FBWCxDQUF0Qjs7QUFFQSxNQUFJLE9BQU9BLGNBQWMsQ0FBQ2lCLGtCQUF0QixLQUE2QyxVQUFqRCxFQUE2RDtBQUMzRCxVQUFNakIsY0FBYyxDQUFDaUIsa0JBQWYsQ0FBa0NQLEdBQWxDLEVBQXVDO0FBQUVJLE1BQUFBO0FBQUYsS0FBdkMsQ0FBTjtBQUNBLFVBQU1JLFdBQVcsR0FBRyxNQUFNLHlDQUFtQlIsR0FBbkIsQ0FBMUI7QUFDQSw0Q0FBc0JRLFdBQXRCO0FBQ0EsVUFBTUMsaUJBQUdDLFNBQUgsQ0FBYWhCLGNBQUtDLElBQUwsQ0FBVUssR0FBVixFQUFlLGNBQWYsQ0FBYixFQUE2Q1EsV0FBN0MsRUFBMEQ7QUFBRUcsTUFBQUEsTUFBTSxFQUFFO0FBQVYsS0FBMUQsQ0FBTjtBQUNEOztBQUVELFFBQU0sd0JBQVMsa0NBQVQsRUFBNkMsWUFBWTtBQUM3RHhCLElBQUFBLENBQUMsQ0FBQyx5QkFBRCxDQUFEO0FBQ0EsVUFBTSxrQ0FBZWEsR0FBZixFQUFvQlYsY0FBYyxDQUFDc0IsWUFBZixJQUErQixFQUFuRCxDQUFOO0FBQ0F6QixJQUFBQSxDQUFDLENBQUMsNEJBQUQsQ0FBRDtBQUNBLFVBQU0sa0NBQWVhLEdBQWYsRUFBb0JWLGNBQWMsQ0FBQ3VCLGVBQWYsSUFBa0MsRUFBdEQsRUFBMERDLDZCQUFRQyxHQUFsRSxDQUFOO0FBQ0QsR0FMSyxDQUFOO0FBT0EsUUFBTSxzQkFBUWYsR0FBUixDQUFOO0FBQ0QsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzeW5jT3JhIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2FzeW5jLW9yYSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgRm9yZ2VUZW1wbGF0ZSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5pbXBvcnQgZmluZFRlbXBsYXRlIGZyb20gJy4vaW5pdC1zY3JpcHRzL2ZpbmQtdGVtcGxhdGUnO1xuaW1wb3J0IGluaXREaXJlY3RvcnkgZnJvbSAnLi9pbml0LXNjcmlwdHMvaW5pdC1kaXJlY3RvcnknO1xuaW1wb3J0IGluaXRHaXQgZnJvbSAnLi9pbml0LXNjcmlwdHMvaW5pdC1naXQnO1xuaW1wb3J0IGluaXROUE0gZnJvbSAnLi9pbml0LXNjcmlwdHMvaW5pdC1ucG0nO1xuaW1wb3J0IGluc3RhbGxEZXBMaXN0LCB7IERlcFR5cGUgfSBmcm9tICcuLi91dGlsL2luc3RhbGwtZGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IHJlYWRSYXdQYWNrYWdlSnNvbiB9IGZyb20gJy4uL3V0aWwvcmVhZC1wYWNrYWdlLWpzb24nO1xuaW1wb3J0IHsgc2V0SW5pdGlhbEZvcmdlQ29uZmlnIH0gZnJvbSAnLi4vdXRpbC9mb3JnZS1jb25maWcnO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOmluaXQnKTtcblxuZXhwb3J0IGludGVyZmFjZSBJbml0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgYXBwIHRvIGJlIGluaXRpYWxpemVkXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gY29weSBUcmF2aXMgYW5kIEFwcFZleW9yIENJIGZpbGVzXG4gICAqL1xuICBjb3B5Q0lGaWxlcz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIG92ZXJ3cml0ZSBhbiBleGlzdGluZyBkaXJlY3RvcnlcbiAgICovXG4gIGZvcmNlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRoZSBjdXN0b20gdGVtcGxhdGUgdG8gdXNlLiBJZiBsZWZ0IGVtcHR5LCB0aGUgZGVmYXVsdCB0ZW1wbGF0ZSBpcyB1c2VkXG4gICAqL1xuICB0ZW1wbGF0ZT86IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUZW1wbGF0ZSh0ZW1wbGF0ZTogc3RyaW5nLCB0ZW1wbGF0ZU1vZHVsZTogRm9yZ2VUZW1wbGF0ZSk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAoIXRlbXBsYXRlTW9kdWxlLnJlcXVpcmVkRm9yZ2VWZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXNlIGEgdGVtcGxhdGUgKCR7dGVtcGxhdGV9KSB3aXRoIHRoaXMgdmVyc2lvbiBvZiBFbGVjdHJvbiBGb3JnZSwgYXMgaXQgZG9lcyBub3Qgc3BlY2lmeSBpdHMgcmVxdWlyZWQgRm9yZ2UgdmVyc2lvbi5gKTtcbiAgfVxuXG4gIGNvbnN0IGZvcmdlVmVyc2lvbiA9IChhd2FpdCByZWFkUmF3UGFja2FnZUpzb24ocGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJykpKS52ZXJzaW9uO1xuICBpZiAoIXNlbXZlci5zYXRpc2ZpZXMoZm9yZ2VWZXJzaW9uLCB0ZW1wbGF0ZU1vZHVsZS5yZXF1aXJlZEZvcmdlVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGVtcGxhdGUgKCR7dGVtcGxhdGV9KSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoaXMgdmVyc2lvbiBvZiBFbGVjdHJvbiBGb3JnZSAoJHtmb3JnZVZlcnNpb259KSwgaXQgcmVxdWlyZXMgJHt0ZW1wbGF0ZU1vZHVsZS5yZXF1aXJlZEZvcmdlVmVyc2lvbn1gXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoeyBkaXIgPSBwcm9jZXNzLmN3ZCgpLCBpbnRlcmFjdGl2ZSA9IGZhbHNlLCBjb3B5Q0lGaWxlcyA9IGZhbHNlLCBmb3JjZSA9IGZhbHNlLCB0ZW1wbGF0ZSA9ICdiYXNlJyB9OiBJbml0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhc3luY09yYS5pbnRlcmFjdGl2ZSA9IGludGVyYWN0aXZlO1xuXG4gIGQoYEluaXRpYWxpemluZyBpbjogJHtkaXJ9YCk7XG5cbiAgYXdhaXQgaW5pdERpcmVjdG9yeShkaXIsIGZvcmNlKTtcbiAgYXdhaXQgaW5pdEdpdChkaXIpO1xuICBjb25zdCB0ZW1wbGF0ZU1vZHVsZSA9IGF3YWl0IGZpbmRUZW1wbGF0ZShkaXIsIHRlbXBsYXRlKTtcblxuICBhd2FpdCB2YWxpZGF0ZVRlbXBsYXRlKHRlbXBsYXRlLCB0ZW1wbGF0ZU1vZHVsZSk7XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZU1vZHVsZS5pbml0aWFsaXplVGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhd2FpdCB0ZW1wbGF0ZU1vZHVsZS5pbml0aWFsaXplVGVtcGxhdGUoZGlyLCB7IGNvcHlDSUZpbGVzIH0pO1xuICAgIGNvbnN0IHBhY2thZ2VKU09OID0gYXdhaXQgcmVhZFJhd1BhY2thZ2VKc29uKGRpcik7XG4gICAgc2V0SW5pdGlhbEZvcmdlQ29uZmlnKHBhY2thZ2VKU09OKTtcbiAgICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5qb2luKGRpciwgJ3BhY2thZ2UuanNvbicpLCBwYWNrYWdlSlNPTiwgeyBzcGFjZXM6IDIgfSk7XG4gIH1cblxuICBhd2FpdCBhc3luY09yYSgnSW5zdGFsbGluZyBUZW1wbGF0ZSBEZXBlbmRlbmNpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgZCgnaW5zdGFsbGluZyBkZXBlbmRlbmNpZXMnKTtcbiAgICBhd2FpdCBpbnN0YWxsRGVwTGlzdChkaXIsIHRlbXBsYXRlTW9kdWxlLmRlcGVuZGVuY2llcyB8fCBbXSk7XG4gICAgZCgnaW5zdGFsbGluZyBkZXZEZXBlbmRlbmNpZXMnKTtcbiAgICBhd2FpdCBpbnN0YWxsRGVwTGlzdChkaXIsIHRlbXBsYXRlTW9kdWxlLmRldkRlcGVuZGVuY2llcyB8fCBbXSwgRGVwVHlwZS5ERVYpO1xuICB9KTtcblxuICBhd2FpdCBpbml0TlBNKGRpcik7XG59O1xuIl19