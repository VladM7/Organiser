"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.rpmArch = rpmArch;

require("source-map-support/register");

var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function rpmArch(nodeArch) {
  switch (nodeArch) {
    case 'ia32':
      return 'i386';

    case 'x64':
      return 'x86_64';

    case 'armv7l':
      return 'armv7hl';

    case 'arm':
      return 'armv6hl';

    default:
      return nodeArch;
  }
}

class MakerRpm extends _makerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'rpm');

    _defineProperty(this, "defaultPlatforms", ['linux']);

    _defineProperty(this, "requiredExternalBinaries", ['rpmbuild']);
  }

  isSupportedOnCurrentPlatform() {
    return this.isInstalled('electron-installer-redhat');
  }

  async make({
    dir,
    makeDir,
    targetArch
  }) {
    // eslint-disable-next-line global-require, import/no-unresolved, node/no-missing-require
    const installer = require('electron-installer-redhat');

    const outDir = _path.default.resolve(makeDir, 'rpm', targetArch);

    await this.ensureDirectory(outDir);
    const {
      packagePaths
    } = await installer({ ...this.config,
      arch: rpmArch(targetArch),
      src: dir,
      dest: outDir,
      rename: undefined
    });
    return packagePaths;
  }

}

exports.default = MakerRpm;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlclJwbS50cyJdLCJuYW1lcyI6WyJycG1BcmNoIiwibm9kZUFyY2giLCJNYWtlclJwbSIsIk1ha2VyQmFzZSIsImlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0iLCJpc0luc3RhbGxlZCIsIm1ha2UiLCJkaXIiLCJtYWtlRGlyIiwidGFyZ2V0QXJjaCIsImluc3RhbGxlciIsInJlcXVpcmUiLCJvdXREaXIiLCJwYXRoIiwicmVzb2x2ZSIsImVuc3VyZURpcmVjdG9yeSIsInBhY2thZ2VQYXRocyIsImNvbmZpZyIsImFyY2giLCJzcmMiLCJkZXN0IiwicmVuYW1lIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBRUE7Ozs7OztBQUlPLFNBQVNBLE9BQVQsQ0FBaUJDLFFBQWpCLEVBQThDO0FBQ25ELFVBQVFBLFFBQVI7QUFDRSxTQUFLLE1BQUw7QUFDRSxhQUFPLE1BQVA7O0FBQ0YsU0FBSyxLQUFMO0FBQ0UsYUFBTyxRQUFQOztBQUNGLFNBQUssUUFBTDtBQUNFLGFBQU8sU0FBUDs7QUFDRixTQUFLLEtBQUw7QUFDRSxhQUFPLFNBQVA7O0FBQ0Y7QUFDRSxhQUFPQSxRQUFQO0FBVko7QUFZRDs7QUFFYyxNQUFNQyxRQUFOLFNBQXVCQyxrQkFBdkIsQ0FBaUQ7QUFBQTtBQUFBOztBQUFBLGtDQUN2RCxLQUR1RDs7QUFBQSw4Q0FHMUIsQ0FBQyxPQUFELENBSDBCOztBQUFBLHNEQUt6QixDQUFDLFVBQUQsQ0FMeUI7QUFBQTs7QUFPOURDLEVBQUFBLDRCQUE0QixHQUFZO0FBQ3RDLFdBQU8sS0FBS0MsV0FBTCxDQUFpQiwyQkFBakIsQ0FBUDtBQUNEOztBQUVTLFFBQUpDLElBQUksQ0FBQztBQUFFQyxJQUFBQSxHQUFGO0FBQU9DLElBQUFBLE9BQVA7QUFBZ0JDLElBQUFBO0FBQWhCLEdBQUQsRUFBZ0U7QUFDeEU7QUFDQSxVQUFNQyxTQUFTLEdBQUdDLE9BQU8sQ0FBQywyQkFBRCxDQUF6Qjs7QUFFQSxVQUFNQyxNQUFNLEdBQUdDLGNBQUtDLE9BQUwsQ0FBYU4sT0FBYixFQUFzQixLQUF0QixFQUE2QkMsVUFBN0IsQ0FBZjs7QUFFQSxVQUFNLEtBQUtNLGVBQUwsQ0FBcUJILE1BQXJCLENBQU47QUFDQSxVQUFNO0FBQUVJLE1BQUFBO0FBQUYsUUFBbUIsTUFBTU4sU0FBUyxDQUFDLEVBQ3ZDLEdBQUcsS0FBS08sTUFEK0I7QUFFdkNDLE1BQUFBLElBQUksRUFBRWxCLE9BQU8sQ0FBQ1MsVUFBRCxDQUYwQjtBQUd2Q1UsTUFBQUEsR0FBRyxFQUFFWixHQUhrQztBQUl2Q2EsTUFBQUEsSUFBSSxFQUFFUixNQUppQztBQUt2Q1MsTUFBQUEsTUFBTSxFQUFFQztBQUwrQixLQUFELENBQXhDO0FBT0EsV0FBT04sWUFBUDtBQUNEOztBQTFCNkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWFrZXJCYXNlLCB7IE1ha2VyT3B0aW9ucyB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9tYWtlci1iYXNlJztcbmltcG9ydCB7IEZvcmdlQXJjaCwgRm9yZ2VQbGF0Zm9ybSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IE1ha2VyUnBtQ29uZmlnIH0gZnJvbSAnLi9Db25maWcnO1xuXG5leHBvcnQgZnVuY3Rpb24gcnBtQXJjaChub2RlQXJjaDogRm9yZ2VBcmNoKTogc3RyaW5nIHtcbiAgc3dpdGNoIChub2RlQXJjaCkge1xuICAgIGNhc2UgJ2lhMzInOlxuICAgICAgcmV0dXJuICdpMzg2JztcbiAgICBjYXNlICd4NjQnOlxuICAgICAgcmV0dXJuICd4ODZfNjQnO1xuICAgIGNhc2UgJ2FybXY3bCc6XG4gICAgICByZXR1cm4gJ2FybXY3aGwnO1xuICAgIGNhc2UgJ2FybSc6XG4gICAgICByZXR1cm4gJ2FybXY2aGwnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbm9kZUFyY2g7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFrZXJScG0gZXh0ZW5kcyBNYWtlckJhc2U8TWFrZXJScG1Db25maWc+IHtcbiAgbmFtZSA9ICdycG0nO1xuXG4gIGRlZmF1bHRQbGF0Zm9ybXM6IEZvcmdlUGxhdGZvcm1bXSA9IFsnbGludXgnXTtcblxuICByZXF1aXJlZEV4dGVybmFsQmluYXJpZXM6IHN0cmluZ1tdID0gWydycG1idWlsZCddO1xuXG4gIGlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbnN0YWxsZWQoJ2VsZWN0cm9uLWluc3RhbGxlci1yZWRoYXQnKTtcbiAgfVxuXG4gIGFzeW5jIG1ha2UoeyBkaXIsIG1ha2VEaXIsIHRhcmdldEFyY2ggfTogTWFrZXJPcHRpb25zKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZSwgaW1wb3J0L25vLXVucmVzb2x2ZWQsIG5vZGUvbm8tbWlzc2luZy1yZXF1aXJlXG4gICAgY29uc3QgaW5zdGFsbGVyID0gcmVxdWlyZSgnZWxlY3Ryb24taW5zdGFsbGVyLXJlZGhhdCcpO1xuXG4gICAgY29uc3Qgb3V0RGlyID0gcGF0aC5yZXNvbHZlKG1ha2VEaXIsICdycG0nLCB0YXJnZXRBcmNoKTtcblxuICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyZWN0b3J5KG91dERpcik7XG4gICAgY29uc3QgeyBwYWNrYWdlUGF0aHMgfSA9IGF3YWl0IGluc3RhbGxlcih7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIGFyY2g6IHJwbUFyY2godGFyZ2V0QXJjaCksXG4gICAgICBzcmM6IGRpcixcbiAgICAgIGRlc3Q6IG91dERpcixcbiAgICAgIHJlbmFtZTogdW5kZWZpbmVkLFxuICAgIH0pO1xuICAgIHJldHVybiBwYWNrYWdlUGF0aHM7XG4gIH1cbn1cbiJdfQ==