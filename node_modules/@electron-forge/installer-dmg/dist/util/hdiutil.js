"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unmountImage = exports.mountImage = exports.getMountedImages = void 0;

require("source-map-support/register");

var _crossSpawnPromise = require("@malept/cross-spawn-promise");

var _debug = _interopRequireDefault(require("debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:hdiutil');

const getMountedImages = async () => {
  const output = await (0, _crossSpawnPromise.spawn)('hdiutil', ['info']);
  const mounts = output.toString().split(/====\n/g);
  mounts.shift();
  const mountObjects = [];

  for (const mount of mounts) {
    try {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const mountPath = /\/Volumes\/(.+)\n/g.exec(mount)[1]; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

      const imagePath = /image-path +: +(.+)\n/g.exec(mount)[1];
      mountObjects.push({
        mountPath,
        imagePath
      });
    } catch {// Ignore
    }
  }

  d('identified active mounts', mountObjects);
  return mountObjects;
};

exports.getMountedImages = getMountedImages;

const mountImage = async filePath => {
  d('mounting image:', filePath);
  const output = await (0, _crossSpawnPromise.spawn)('hdiutil', ['attach', '-noautoopen', '-nobrowse', '-noverify', filePath]); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

  const mountPath = /\/Volumes\/(.+)\n/g.exec(output.toString())[1];
  d('mounted at:', mountPath);
  return {
    mountPath,
    imagePath: filePath
  };
};

exports.mountImage = mountImage;

const unmountImage = async mount => {
  d('unmounting current mount:', mount);
  await (0, _crossSpawnPromise.spawn)('hdiutil', ['unmount', '-force', `/Volumes/${mount.mountPath}`]);
};

exports.unmountImage = unmountImage;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2hkaXV0aWwudHMiXSwibmFtZXMiOlsiZCIsImdldE1vdW50ZWRJbWFnZXMiLCJvdXRwdXQiLCJtb3VudHMiLCJ0b1N0cmluZyIsInNwbGl0Iiwic2hpZnQiLCJtb3VudE9iamVjdHMiLCJtb3VudCIsIm1vdW50UGF0aCIsImV4ZWMiLCJpbWFnZVBhdGgiLCJwdXNoIiwibW91bnRJbWFnZSIsImZpbGVQYXRoIiwidW5tb3VudEltYWdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7OztBQUVBLE1BQU1BLENBQUMsR0FBRyxvQkFBTSx3QkFBTixDQUFWOztBQU9PLE1BQU1DLGdCQUFnQixHQUFHLFlBQThCO0FBQzVELFFBQU1DLE1BQU0sR0FBRyxNQUFNLDhCQUFNLFNBQU4sRUFBaUIsQ0FBQyxNQUFELENBQWpCLENBQXJCO0FBQ0EsUUFBTUMsTUFBTSxHQUFHRCxNQUFNLENBQUNFLFFBQVAsR0FBa0JDLEtBQWxCLENBQXdCLFNBQXhCLENBQWY7QUFDQUYsRUFBQUEsTUFBTSxDQUFDRyxLQUFQO0FBRUEsUUFBTUMsWUFBWSxHQUFHLEVBQXJCOztBQUVBLE9BQUssTUFBTUMsS0FBWCxJQUFvQkwsTUFBcEIsRUFBNEI7QUFDMUIsUUFBSTtBQUNGO0FBQ0EsWUFBTU0sU0FBUyxHQUFHLHFCQUFxQkMsSUFBckIsQ0FBMEJGLEtBQTFCLEVBQWtDLENBQWxDLENBQWxCLENBRkUsQ0FHRjs7QUFDQSxZQUFNRyxTQUFTLEdBQUcseUJBQXlCRCxJQUF6QixDQUE4QkYsS0FBOUIsRUFBc0MsQ0FBdEMsQ0FBbEI7QUFDQUQsTUFBQUEsWUFBWSxDQUFDSyxJQUFiLENBQWtCO0FBQUVILFFBQUFBLFNBQUY7QUFBYUUsUUFBQUE7QUFBYixPQUFsQjtBQUNELEtBTkQsQ0FNRSxNQUFNLENBQ047QUFDRDtBQUNGOztBQUVEWCxFQUFBQSxDQUFDLENBQUMsMEJBQUQsRUFBNkJPLFlBQTdCLENBQUQ7QUFDQSxTQUFPQSxZQUFQO0FBQ0QsQ0FyQk07Ozs7QUF1QkEsTUFBTU0sVUFBVSxHQUFHLE1BQU9DLFFBQVAsSUFBNEM7QUFDcEVkLEVBQUFBLENBQUMsQ0FBQyxpQkFBRCxFQUFvQmMsUUFBcEIsQ0FBRDtBQUNBLFFBQU1aLE1BQU0sR0FBRyxNQUFNLDhCQUFNLFNBQU4sRUFBaUIsQ0FBQyxRQUFELEVBQVcsYUFBWCxFQUEwQixXQUExQixFQUF1QyxXQUF2QyxFQUFvRFksUUFBcEQsQ0FBakIsQ0FBckIsQ0FGb0UsQ0FHcEU7O0FBQ0EsUUFBTUwsU0FBUyxHQUFHLHFCQUFxQkMsSUFBckIsQ0FBMEJSLE1BQU0sQ0FBQ0UsUUFBUCxFQUExQixFQUE4QyxDQUE5QyxDQUFsQjtBQUNBSixFQUFBQSxDQUFDLENBQUMsYUFBRCxFQUFnQlMsU0FBaEIsQ0FBRDtBQUVBLFNBQU87QUFDTEEsSUFBQUEsU0FESztBQUVMRSxJQUFBQSxTQUFTLEVBQUVHO0FBRk4sR0FBUDtBQUlELENBWE07Ozs7QUFhQSxNQUFNQyxZQUFZLEdBQUcsTUFBT1AsS0FBUCxJQUF1QztBQUNqRVIsRUFBQUEsQ0FBQyxDQUFDLDJCQUFELEVBQThCUSxLQUE5QixDQUFEO0FBQ0EsUUFBTSw4QkFBTSxTQUFOLEVBQWlCLENBQUMsU0FBRCxFQUFZLFFBQVosRUFBdUIsWUFBV0EsS0FBSyxDQUFDQyxTQUFVLEVBQWxELENBQWpCLENBQU47QUFDRCxDQUhNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdAbWFsZXB0L2Nyb3NzLXNwYXduLXByb21pc2UnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTpoZGl1dGlsJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW91bnQge1xuICBtb3VudFBhdGg6IHN0cmluZztcbiAgaW1hZ2VQYXRoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRNb3VudGVkSW1hZ2VzID0gYXN5bmMgKCk6IFByb21pc2U8TW91bnRbXT4gPT4ge1xuICBjb25zdCBvdXRwdXQgPSBhd2FpdCBzcGF3bignaGRpdXRpbCcsIFsnaW5mbyddKTtcbiAgY29uc3QgbW91bnRzID0gb3V0cHV0LnRvU3RyaW5nKCkuc3BsaXQoLz09PT1cXG4vZyk7XG4gIG1vdW50cy5zaGlmdCgpO1xuXG4gIGNvbnN0IG1vdW50T2JqZWN0cyA9IFtdO1xuXG4gIGZvciAoY29uc3QgbW91bnQgb2YgbW91bnRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICBjb25zdCBtb3VudFBhdGggPSAvXFwvVm9sdW1lc1xcLyguKylcXG4vZy5leGVjKG1vdW50KSFbMV07XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgY29uc3QgaW1hZ2VQYXRoID0gL2ltYWdlLXBhdGggKzogKyguKylcXG4vZy5leGVjKG1vdW50KSFbMV07XG4gICAgICBtb3VudE9iamVjdHMucHVzaCh7IG1vdW50UGF0aCwgaW1hZ2VQYXRoIH0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlXG4gICAgfVxuICB9XG5cbiAgZCgnaWRlbnRpZmllZCBhY3RpdmUgbW91bnRzJywgbW91bnRPYmplY3RzKTtcbiAgcmV0dXJuIG1vdW50T2JqZWN0cztcbn07XG5cbmV4cG9ydCBjb25zdCBtb3VudEltYWdlID0gYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPE1vdW50PiA9PiB7XG4gIGQoJ21vdW50aW5nIGltYWdlOicsIGZpbGVQYXRoKTtcbiAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgc3Bhd24oJ2hkaXV0aWwnLCBbJ2F0dGFjaCcsICctbm9hdXRvb3BlbicsICctbm9icm93c2UnLCAnLW5vdmVyaWZ5JywgZmlsZVBhdGhdKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgY29uc3QgbW91bnRQYXRoID0gL1xcL1ZvbHVtZXNcXC8oLispXFxuL2cuZXhlYyhvdXRwdXQudG9TdHJpbmcoKSkhWzFdO1xuICBkKCdtb3VudGVkIGF0OicsIG1vdW50UGF0aCk7XG5cbiAgcmV0dXJuIHtcbiAgICBtb3VudFBhdGgsXG4gICAgaW1hZ2VQYXRoOiBmaWxlUGF0aCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1bm1vdW50SW1hZ2UgPSBhc3luYyAobW91bnQ6IE1vdW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGQoJ3VubW91bnRpbmcgY3VycmVudCBtb3VudDonLCBtb3VudCk7XG4gIGF3YWl0IHNwYXduKCdoZGl1dGlsJywgWyd1bm1vdW50JywgJy1mb3JjZScsIGAvVm9sdW1lcy8ke21vdW50Lm1vdW50UGF0aH1gXSk7XG59O1xuIl19