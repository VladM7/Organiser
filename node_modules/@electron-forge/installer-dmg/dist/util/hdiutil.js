"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unmountImage = exports.mountImage = exports.getMountedImages = void 0;

require("source-map-support/register");

var _crossSpawnPromise = require("@malept/cross-spawn-promise");

var _debug = _interopRequireDefault(require("debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug.default)('electron-forge:hdiutil');

const getMountedImages = async () => {
  const output = await (0, _crossSpawnPromise.spawn)('hdiutil', ['info']);
  const mounts = output.toString().split(/====\n/g);
  mounts.shift();
  const mountObjects = [];

  for (const mount of mounts) {
    try {
      const mountPath = /\/Volumes\/(.+)\n/g.exec(mount)[1];
      const imagePath = /image-path +: +(.+)\n/g.exec(mount)[1];
      mountObjects.push({
        mountPath,
        imagePath
      });
    } catch (err) {// Ignore
    }
  }

  d('identified active mounts', mountObjects);
  return mountObjects;
};

exports.getMountedImages = getMountedImages;

const mountImage = async filePath => {
  d('mounting image:', filePath);
  const output = await (0, _crossSpawnPromise.spawn)('hdiutil', ['attach', '-noautoopen', '-nobrowse', '-noverify', filePath]);
  const mountPath = /\/Volumes\/(.+)\n/g.exec(output.toString())[1];
  d('mounted at:', mountPath);
  return {
    mountPath,
    imagePath: filePath
  };
};

exports.mountImage = mountImage;

const unmountImage = async mount => {
  d('unmounting current mount:', mount);
  await (0, _crossSpawnPromise.spawn)('hdiutil', ['unmount', '-force', `/Volumes/${mount.mountPath}`]);
};

exports.unmountImage = unmountImage;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2hkaXV0aWwudHMiXSwibmFtZXMiOlsiZCIsImdldE1vdW50ZWRJbWFnZXMiLCJvdXRwdXQiLCJtb3VudHMiLCJ0b1N0cmluZyIsInNwbGl0Iiwic2hpZnQiLCJtb3VudE9iamVjdHMiLCJtb3VudCIsIm1vdW50UGF0aCIsImV4ZWMiLCJpbWFnZVBhdGgiLCJwdXNoIiwiZXJyIiwibW91bnRJbWFnZSIsImZpbGVQYXRoIiwidW5tb3VudEltYWdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7OztBQUVBLE1BQU1BLENBQUMsR0FBRyxvQkFBTSx3QkFBTixDQUFWOztBQU9PLE1BQU1DLGdCQUFnQixHQUFHLFlBQThCO0FBQzVELFFBQU1DLE1BQU0sR0FBRyxNQUFNLDhCQUFNLFNBQU4sRUFBaUIsQ0FBQyxNQUFELENBQWpCLENBQXJCO0FBQ0EsUUFBTUMsTUFBTSxHQUFHRCxNQUFNLENBQUNFLFFBQVAsR0FBa0JDLEtBQWxCLENBQXdCLFNBQXhCLENBQWY7QUFDQUYsRUFBQUEsTUFBTSxDQUFDRyxLQUFQO0FBRUEsUUFBTUMsWUFBWSxHQUFHLEVBQXJCOztBQUVBLE9BQUssTUFBTUMsS0FBWCxJQUFvQkwsTUFBcEIsRUFBNEI7QUFDMUIsUUFBSTtBQUNGLFlBQU1NLFNBQVMsR0FBRyxxQkFBcUJDLElBQXJCLENBQTBCRixLQUExQixFQUFrQyxDQUFsQyxDQUFsQjtBQUNBLFlBQU1HLFNBQVMsR0FBRyx5QkFBeUJELElBQXpCLENBQThCRixLQUE5QixFQUFzQyxDQUF0QyxDQUFsQjtBQUNBRCxNQUFBQSxZQUFZLENBQUNLLElBQWIsQ0FBa0I7QUFBRUgsUUFBQUEsU0FBRjtBQUFhRSxRQUFBQTtBQUFiLE9BQWxCO0FBQ0QsS0FKRCxDQUlFLE9BQU9FLEdBQVAsRUFBWSxDQUNaO0FBQ0Q7QUFDRjs7QUFFRGIsRUFBQUEsQ0FBQyxDQUFDLDBCQUFELEVBQTZCTyxZQUE3QixDQUFEO0FBQ0EsU0FBT0EsWUFBUDtBQUNELENBbkJNOzs7O0FBcUJBLE1BQU1PLFVBQVUsR0FBRyxNQUFPQyxRQUFQLElBQTRDO0FBQ3BFZixFQUFBQSxDQUFDLENBQUMsaUJBQUQsRUFBb0JlLFFBQXBCLENBQUQ7QUFDQSxRQUFNYixNQUFNLEdBQUcsTUFBTSw4QkFBTSxTQUFOLEVBQWlCLENBQUMsUUFBRCxFQUFXLGFBQVgsRUFBMEIsV0FBMUIsRUFBdUMsV0FBdkMsRUFBb0RhLFFBQXBELENBQWpCLENBQXJCO0FBQ0EsUUFBTU4sU0FBUyxHQUFHLHFCQUFxQkMsSUFBckIsQ0FBMEJSLE1BQU0sQ0FBQ0UsUUFBUCxFQUExQixFQUE4QyxDQUE5QyxDQUFsQjtBQUNBSixFQUFBQSxDQUFDLENBQUMsYUFBRCxFQUFnQlMsU0FBaEIsQ0FBRDtBQUVBLFNBQU87QUFDTEEsSUFBQUEsU0FESztBQUVMRSxJQUFBQSxTQUFTLEVBQUVJO0FBRk4sR0FBUDtBQUlELENBVk07Ozs7QUFZQSxNQUFNQyxZQUFZLEdBQUcsTUFBT1IsS0FBUCxJQUF3QjtBQUNsRFIsRUFBQUEsQ0FBQyxDQUFDLDJCQUFELEVBQThCUSxLQUE5QixDQUFEO0FBQ0EsUUFBTSw4QkFBTSxTQUFOLEVBQWlCLENBQUMsU0FBRCxFQUFZLFFBQVosRUFBdUIsWUFBV0EsS0FBSyxDQUFDQyxTQUFVLEVBQWxELENBQWpCLENBQU47QUFDRCxDQUhNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdAbWFsZXB0L2Nyb3NzLXNwYXduLXByb21pc2UnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTpoZGl1dGlsJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW91bnQge1xuICBtb3VudFBhdGg6IHN0cmluZztcbiAgaW1hZ2VQYXRoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRNb3VudGVkSW1hZ2VzID0gYXN5bmMgKCk6IFByb21pc2U8TW91bnRbXT4gPT4ge1xuICBjb25zdCBvdXRwdXQgPSBhd2FpdCBzcGF3bignaGRpdXRpbCcsIFsnaW5mbyddKTtcbiAgY29uc3QgbW91bnRzID0gb3V0cHV0LnRvU3RyaW5nKCkuc3BsaXQoLz09PT1cXG4vZyk7XG4gIG1vdW50cy5zaGlmdCgpO1xuXG4gIGNvbnN0IG1vdW50T2JqZWN0cyA9IFtdO1xuXG4gIGZvciAoY29uc3QgbW91bnQgb2YgbW91bnRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1vdW50UGF0aCA9IC9cXC9Wb2x1bWVzXFwvKC4rKVxcbi9nLmV4ZWMobW91bnQpIVsxXTtcbiAgICAgIGNvbnN0IGltYWdlUGF0aCA9IC9pbWFnZS1wYXRoICs6ICsoLispXFxuL2cuZXhlYyhtb3VudCkhWzFdO1xuICAgICAgbW91bnRPYmplY3RzLnB1c2goeyBtb3VudFBhdGgsIGltYWdlUGF0aCB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIElnbm9yZVxuICAgIH1cbiAgfVxuXG4gIGQoJ2lkZW50aWZpZWQgYWN0aXZlIG1vdW50cycsIG1vdW50T2JqZWN0cyk7XG4gIHJldHVybiBtb3VudE9iamVjdHM7XG59O1xuXG5leHBvcnQgY29uc3QgbW91bnRJbWFnZSA9IGFzeW5jIChmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxNb3VudD4gPT4ge1xuICBkKCdtb3VudGluZyBpbWFnZTonLCBmaWxlUGF0aCk7XG4gIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNwYXduKCdoZGl1dGlsJywgWydhdHRhY2gnLCAnLW5vYXV0b29wZW4nLCAnLW5vYnJvd3NlJywgJy1ub3ZlcmlmeScsIGZpbGVQYXRoXSk7XG4gIGNvbnN0IG1vdW50UGF0aCA9IC9cXC9Wb2x1bWVzXFwvKC4rKVxcbi9nLmV4ZWMob3V0cHV0LnRvU3RyaW5nKCkpIVsxXTtcbiAgZCgnbW91bnRlZCBhdDonLCBtb3VudFBhdGgpO1xuXG4gIHJldHVybiB7XG4gICAgbW91bnRQYXRoLFxuICAgIGltYWdlUGF0aDogZmlsZVBhdGgsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdW5tb3VudEltYWdlID0gYXN5bmMgKG1vdW50OiBNb3VudCkgPT4ge1xuICBkKCd1bm1vdW50aW5nIGN1cnJlbnQgbW91bnQ6JywgbW91bnQpO1xuICBhd2FpdCBzcGF3bignaGRpdXRpbCcsIFsndW5tb3VudCcsICctZm9yY2UnLCBgL1ZvbHVtZXMvJHttb3VudC5tb3VudFBhdGh9YF0pO1xufTtcbiJdfQ==