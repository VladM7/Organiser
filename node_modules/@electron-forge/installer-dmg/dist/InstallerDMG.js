"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _installerDarwin = _interopRequireDefault(require("@electron-forge/installer-darwin"));

var _crossSpawnPromise = require("@malept/cross-spawn-promise");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _hdiutil = require("./util/hdiutil");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class InstallerDMG extends _installerDarwin.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'dmg');
  }

  async install({
    filePath,
    installSpinner
  }) {
    const mounts = await (0, _hdiutil.getMountedImages)();
    let targetMount = mounts.find(mount => mount.imagePath === filePath);

    if (!targetMount) {
      targetMount = await (0, _hdiutil.mountImage)(filePath);
    }

    try {
      const volumePath = _path.default.resolve('/Volumes', targetMount.mountPath);

      const appName = (await _fsExtra.default.readdir(volumePath)).find(file => file.endsWith('.app'));

      if (!appName) {
        throw new Error('Failed to find .app file in DMG');
      }

      const appPath = _path.default.resolve(volumePath, appName);

      const targetApplicationPath = `/Applications/${_path.default.basename(appPath)}`;
      await this.moveApp(appPath, targetApplicationPath, installSpinner, true);
      await (0, _crossSpawnPromise.spawn)('open', ['-R', targetApplicationPath], {
        detached: true
      });
    } finally {
      await (0, _hdiutil.unmountImage)(targetMount);
    }
  }

}

exports.default = InstallerDMG;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9JbnN0YWxsZXJETUcudHMiXSwibmFtZXMiOlsiSW5zdGFsbGVyRE1HIiwiSW5zdGFsbGVyRGFyd2luIiwiaW5zdGFsbCIsImZpbGVQYXRoIiwiaW5zdGFsbFNwaW5uZXIiLCJtb3VudHMiLCJ0YXJnZXRNb3VudCIsImZpbmQiLCJtb3VudCIsImltYWdlUGF0aCIsInZvbHVtZVBhdGgiLCJwYXRoIiwicmVzb2x2ZSIsIm1vdW50UGF0aCIsImFwcE5hbWUiLCJmcyIsInJlYWRkaXIiLCJmaWxlIiwiZW5kc1dpdGgiLCJFcnJvciIsImFwcFBhdGgiLCJ0YXJnZXRBcHBsaWNhdGlvblBhdGgiLCJiYXNlbmFtZSIsIm1vdmVBcHAiLCJkZXRhY2hlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7OztBQUVlLE1BQU1BLFlBQU4sU0FBMkJDLHdCQUEzQixDQUEyQztBQUFBO0FBQUE7O0FBQUEsa0NBQ2pELEtBRGlEO0FBQUE7O0FBRzNDLFFBQVBDLE9BQU8sQ0FBQztBQUFFQyxJQUFBQSxRQUFGO0FBQVlDLElBQUFBO0FBQVosR0FBRCxFQUFnRTtBQUMzRSxVQUFNQyxNQUFNLEdBQUcsTUFBTSxnQ0FBckI7QUFDQSxRQUFJQyxXQUFXLEdBQUdELE1BQU0sQ0FBQ0UsSUFBUCxDQUFhQyxLQUFELElBQVdBLEtBQUssQ0FBQ0MsU0FBTixLQUFvQk4sUUFBM0MsQ0FBbEI7O0FBRUEsUUFBSSxDQUFDRyxXQUFMLEVBQWtCO0FBQ2hCQSxNQUFBQSxXQUFXLEdBQUcsTUFBTSx5QkFBV0gsUUFBWCxDQUFwQjtBQUNEOztBQUVELFFBQUk7QUFDRixZQUFNTyxVQUFVLEdBQUdDLGNBQUtDLE9BQUwsQ0FBYSxVQUFiLEVBQXlCTixXQUFXLENBQUNPLFNBQXJDLENBQW5COztBQUNBLFlBQU1DLE9BQU8sR0FBRyxDQUFDLE1BQU1DLGlCQUFHQyxPQUFILENBQVdOLFVBQVgsQ0FBUCxFQUErQkgsSUFBL0IsQ0FBcUNVLElBQUQsSUFBVUEsSUFBSSxDQUFDQyxRQUFMLENBQWMsTUFBZCxDQUE5QyxDQUFoQjs7QUFDQSxVQUFJLENBQUNKLE9BQUwsRUFBYztBQUNaLGNBQU0sSUFBSUssS0FBSixDQUFVLGlDQUFWLENBQU47QUFDRDs7QUFDRCxZQUFNQyxPQUFPLEdBQUdULGNBQUtDLE9BQUwsQ0FBYUYsVUFBYixFQUF5QkksT0FBekIsQ0FBaEI7O0FBQ0EsWUFBTU8scUJBQXFCLEdBQUksaUJBQWdCVixjQUFLVyxRQUFMLENBQWNGLE9BQWQsQ0FBdUIsRUFBdEU7QUFFQSxZQUFNLEtBQUtHLE9BQUwsQ0FBYUgsT0FBYixFQUFzQkMscUJBQXRCLEVBQTZDakIsY0FBN0MsRUFBNkQsSUFBN0QsQ0FBTjtBQUVBLFlBQU0sOEJBQU0sTUFBTixFQUFjLENBQUMsSUFBRCxFQUFPaUIscUJBQVAsQ0FBZCxFQUE2QztBQUFFRyxRQUFBQSxRQUFRLEVBQUU7QUFBWixPQUE3QyxDQUFOO0FBQ0QsS0FaRCxTQVlVO0FBQ1IsWUFBTSwyQkFBYWxCLFdBQWIsQ0FBTjtBQUNEO0FBQ0Y7O0FBMUJ1RCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJbnN0YWxsZXJEYXJ3aW4sIHsgSW5zdGFsbGVyT3B0aW9ucyB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9pbnN0YWxsZXItZGFyd2luJztcblxuaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdAbWFsZXB0L2Nyb3NzLXNwYXduLXByb21pc2UnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBnZXRNb3VudGVkSW1hZ2VzLCBtb3VudEltYWdlLCB1bm1vdW50SW1hZ2UgfSBmcm9tICcuL3V0aWwvaGRpdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluc3RhbGxlckRNRyBleHRlbmRzIEluc3RhbGxlckRhcndpbiB7XG4gIG5hbWUgPSAnZG1nJztcblxuICBhc3luYyBpbnN0YWxsKHsgZmlsZVBhdGgsIGluc3RhbGxTcGlubmVyIH06IEluc3RhbGxlck9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtb3VudHMgPSBhd2FpdCBnZXRNb3VudGVkSW1hZ2VzKCk7XG4gICAgbGV0IHRhcmdldE1vdW50ID0gbW91bnRzLmZpbmQoKG1vdW50KSA9PiBtb3VudC5pbWFnZVBhdGggPT09IGZpbGVQYXRoKTtcblxuICAgIGlmICghdGFyZ2V0TW91bnQpIHtcbiAgICAgIHRhcmdldE1vdW50ID0gYXdhaXQgbW91bnRJbWFnZShmaWxlUGF0aCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZvbHVtZVBhdGggPSBwYXRoLnJlc29sdmUoJy9Wb2x1bWVzJywgdGFyZ2V0TW91bnQubW91bnRQYXRoKTtcbiAgICAgIGNvbnN0IGFwcE5hbWUgPSAoYXdhaXQgZnMucmVhZGRpcih2b2x1bWVQYXRoKSkuZmluZCgoZmlsZSkgPT4gZmlsZS5lbmRzV2l0aCgnLmFwcCcpKTtcbiAgICAgIGlmICghYXBwTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIC5hcHAgZmlsZSBpbiBETUcnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFwcFBhdGggPSBwYXRoLnJlc29sdmUodm9sdW1lUGF0aCwgYXBwTmFtZSk7XG4gICAgICBjb25zdCB0YXJnZXRBcHBsaWNhdGlvblBhdGggPSBgL0FwcGxpY2F0aW9ucy8ke3BhdGguYmFzZW5hbWUoYXBwUGF0aCl9YDtcblxuICAgICAgYXdhaXQgdGhpcy5tb3ZlQXBwKGFwcFBhdGgsIHRhcmdldEFwcGxpY2F0aW9uUGF0aCwgaW5zdGFsbFNwaW5uZXIsIHRydWUpO1xuXG4gICAgICBhd2FpdCBzcGF3bignb3BlbicsIFsnLVInLCB0YXJnZXRBcHBsaWNhdGlvblBhdGhdLCB7IGRldGFjaGVkOiB0cnVlIH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCB1bm1vdW50SW1hZ2UodGFyZ2V0TW91bnQpO1xuICAgIH1cbiAgfVxufVxuIl19