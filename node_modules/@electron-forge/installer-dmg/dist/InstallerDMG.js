"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _installerDarwin = _interopRequireDefault(require("@electron-forge/installer-darwin"));

var _crossSpawnPromise = require("@malept/cross-spawn-promise");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _hdiutil = require("./util/hdiutil");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class InstallerDMG extends _installerDarwin.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'dmg');
  }

  async install({
    filePath,
    installSpinner
  }) {
    const mounts = await (0, _hdiutil.getMountedImages)();
    let targetMount = mounts.find(mount => mount.imagePath === filePath);

    if (!targetMount) {
      targetMount = await (0, _hdiutil.mountImage)(filePath);
    }

    try {
      const volumePath = _path.default.resolve('/Volumes', targetMount.mountPath);

      const appName = (await _fsExtra.default.readdir(volumePath)).find(file => file.endsWith('.app'));

      if (!appName) {
        throw new Error('Failed to find .app file in DMG');
      }

      const appPath = _path.default.resolve(volumePath, appName);

      const targetApplicationPath = `/Applications/${_path.default.basename(appPath)}`;
      await this.moveApp(appPath, targetApplicationPath, installSpinner, true);
      await (0, _crossSpawnPromise.spawn)('open', ['-R', targetApplicationPath], {
        detached: true
      });
    } finally {
      await (0, _hdiutil.unmountImage)(targetMount);
    }
  }

}

exports.default = InstallerDMG;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9JbnN0YWxsZXJETUcudHMiXSwibmFtZXMiOlsiSW5zdGFsbGVyRE1HIiwiSW5zdGFsbGVyRGFyd2luIiwiaW5zdGFsbCIsImZpbGVQYXRoIiwiaW5zdGFsbFNwaW5uZXIiLCJtb3VudHMiLCJ0YXJnZXRNb3VudCIsImZpbmQiLCJtb3VudCIsImltYWdlUGF0aCIsInZvbHVtZVBhdGgiLCJwYXRoIiwicmVzb2x2ZSIsIm1vdW50UGF0aCIsImFwcE5hbWUiLCJmcyIsInJlYWRkaXIiLCJmaWxlIiwiZW5kc1dpdGgiLCJFcnJvciIsImFwcFBhdGgiLCJ0YXJnZXRBcHBsaWNhdGlvblBhdGgiLCJiYXNlbmFtZSIsIm1vdmVBcHAiLCJkZXRhY2hlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7OztBQUVlLE1BQU1BLFlBQU4sU0FBMkJDLHdCQUEzQixDQUEyQztBQUFBO0FBQUE7O0FBQUEsa0NBQ2pELEtBRGlEO0FBQUE7O0FBRzNDLFFBQVBDLE9BQU8sQ0FBQztBQUNaQyxJQUFBQSxRQURZO0FBRVpDLElBQUFBO0FBRlksR0FBRCxFQUdRO0FBQ25CLFVBQU1DLE1BQU0sR0FBRyxNQUFNLGdDQUFyQjtBQUNBLFFBQUlDLFdBQVcsR0FBR0QsTUFBTSxDQUFDRSxJQUFQLENBQWFDLEtBQUQsSUFBV0EsS0FBSyxDQUFDQyxTQUFOLEtBQW9CTixRQUEzQyxDQUFsQjs7QUFFQSxRQUFJLENBQUNHLFdBQUwsRUFBa0I7QUFDaEJBLE1BQUFBLFdBQVcsR0FBRyxNQUFNLHlCQUFXSCxRQUFYLENBQXBCO0FBQ0Q7O0FBRUQsUUFBSTtBQUNGLFlBQU1PLFVBQVUsR0FBR0MsY0FBS0MsT0FBTCxDQUFhLFVBQWIsRUFBeUJOLFdBQVcsQ0FBQ08sU0FBckMsQ0FBbkI7O0FBQ0EsWUFBTUMsT0FBTyxHQUFHLENBQUMsTUFBTUMsaUJBQUdDLE9BQUgsQ0FBV04sVUFBWCxDQUFQLEVBQStCSCxJQUEvQixDQUFxQ1UsSUFBRCxJQUFVQSxJQUFJLENBQUNDLFFBQUwsQ0FBYyxNQUFkLENBQTlDLENBQWhCOztBQUNBLFVBQUksQ0FBQ0osT0FBTCxFQUFjO0FBQ1osY0FBTSxJQUFJSyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNEOztBQUNELFlBQU1DLE9BQU8sR0FBR1QsY0FBS0MsT0FBTCxDQUFhRixVQUFiLEVBQXlCSSxPQUF6QixDQUFoQjs7QUFDQSxZQUFNTyxxQkFBcUIsR0FBSSxpQkFBZ0JWLGNBQUtXLFFBQUwsQ0FBY0YsT0FBZCxDQUF1QixFQUF0RTtBQUVBLFlBQU0sS0FBS0csT0FBTCxDQUFhSCxPQUFiLEVBQXNCQyxxQkFBdEIsRUFBNkNqQixjQUE3QyxFQUE2RCxJQUE3RCxDQUFOO0FBRUEsWUFBTSw4QkFBTSxNQUFOLEVBQWMsQ0FBQyxJQUFELEVBQU9pQixxQkFBUCxDQUFkLEVBQTZDO0FBQUVHLFFBQUFBLFFBQVEsRUFBRTtBQUFaLE9BQTdDLENBQU47QUFDRCxLQVpELFNBWVU7QUFDUixZQUFNLDJCQUFhbEIsV0FBYixDQUFOO0FBQ0Q7QUFDRjs7QUE3QnVEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEluc3RhbGxlckRhcndpbiwgeyBJbnN0YWxsZXJPcHRpb25zIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2luc3RhbGxlci1kYXJ3aW4nO1xuXG5pbXBvcnQgeyBzcGF3biB9IGZyb20gJ0BtYWxlcHQvY3Jvc3Mtc3Bhd24tcHJvbWlzZSc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IGdldE1vdW50ZWRJbWFnZXMsIG1vdW50SW1hZ2UsIHVubW91bnRJbWFnZSB9IGZyb20gJy4vdXRpbC9oZGl1dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5zdGFsbGVyRE1HIGV4dGVuZHMgSW5zdGFsbGVyRGFyd2luIHtcbiAgbmFtZSA9ICdkbWcnO1xuXG4gIGFzeW5jIGluc3RhbGwoe1xuICAgIGZpbGVQYXRoLFxuICAgIGluc3RhbGxTcGlubmVyLFxuICB9OiBJbnN0YWxsZXJPcHRpb25zKSB7XG4gICAgY29uc3QgbW91bnRzID0gYXdhaXQgZ2V0TW91bnRlZEltYWdlcygpO1xuICAgIGxldCB0YXJnZXRNb3VudCA9IG1vdW50cy5maW5kKChtb3VudCkgPT4gbW91bnQuaW1hZ2VQYXRoID09PSBmaWxlUGF0aCk7XG5cbiAgICBpZiAoIXRhcmdldE1vdW50KSB7XG4gICAgICB0YXJnZXRNb3VudCA9IGF3YWl0IG1vdW50SW1hZ2UoZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2b2x1bWVQYXRoID0gcGF0aC5yZXNvbHZlKCcvVm9sdW1lcycsIHRhcmdldE1vdW50Lm1vdW50UGF0aCk7XG4gICAgICBjb25zdCBhcHBOYW1lID0gKGF3YWl0IGZzLnJlYWRkaXIodm9sdW1lUGF0aCkpLmZpbmQoKGZpbGUpID0+IGZpbGUuZW5kc1dpdGgoJy5hcHAnKSk7XG4gICAgICBpZiAoIWFwcE5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCAuYXBwIGZpbGUgaW4gRE1HJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBhcHBQYXRoID0gcGF0aC5yZXNvbHZlKHZvbHVtZVBhdGgsIGFwcE5hbWUpO1xuICAgICAgY29uc3QgdGFyZ2V0QXBwbGljYXRpb25QYXRoID0gYC9BcHBsaWNhdGlvbnMvJHtwYXRoLmJhc2VuYW1lKGFwcFBhdGgpfWA7XG5cbiAgICAgIGF3YWl0IHRoaXMubW92ZUFwcChhcHBQYXRoLCB0YXJnZXRBcHBsaWNhdGlvblBhdGgsIGluc3RhbGxTcGlubmVyLCB0cnVlKTtcblxuICAgICAgYXdhaXQgc3Bhd24oJ29wZW4nLCBbJy1SJywgdGFyZ2V0QXBwbGljYXRpb25QYXRoXSwgeyBkZXRhY2hlZDogdHJ1ZSB9IGFzIGFueSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IHVubW91bnRJbWFnZSh0YXJnZXRNb3VudCk7XG4gICAgfVxuICB9XG59XG4iXX0=